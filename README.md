# intro-mathmodel

## 1. 解析方法与几何模型

### 1.1. 向量表示法与几何建模基本案例

#### 1.1.1. 几何建模的思想

分析几何问题，在现在这个阶段我们所掌握的方法大体上可以分为三种：

- **传统几何的演绎-证明体系**：这种体系下的方法都是基于已经被证明了的公理与定理体系（例如勾股定理、正弦定理、圆幂定理等），在解决问题的过程中更强调分析而非计算，往往是通过构造辅助线、辅助平面等利用严密的逻辑推理步步为营推导出最后的结果。这种方法往往分析起来会更加困难，但减少了计算量。
- **基于向量的计算化几何**：向量被引入几何当中最初的目的是为了表示有向线段，但后来大家发现基于向量的一些运算特性可以把一些数量问题统一化。几何图形中的边长、角度、面积可以转化为向量的模长、内积等求解，平行、垂直等可以转化为向量共线、内积为0等求解，就可以把所有几何问题都变成可计算的问题。这样的方法更加重视计算，并且除了传统的几何向量外，还可以构造直角坐标系从而获得坐标向量，运算更加方便。
- **基于极坐标与方程的解析几何**：这种方法其实可以回溯到当初学圆锥曲线的时期，把几何图形的相交、相切、相离抽象成方程解的问题。后来又学习过极坐标和参数方程，就会发现利用极坐标和参数方程去表示曲线实在是太方便了。这样的方法就可以把几何问题转化成一个代数问题来求解，大大提高了求解的效率。

##### 一些常见的公式与定理

- **三角形中的角度关系**：这是几何学中的基本概念之一，涉及到三角形内角和定理（三角形的三个内角之和等于180∘180∘）、直角三角形的角度关系（一个角为90∘90∘，另外两个角之和为90∘90∘）等。

- **勾股定理**：这是直角三角形中最著名的定理之一，表明直角三角形的两条直角边的平方和等于斜边的平方。即如果直角三角形的直角边长分别为*a*和*b*，斜边长为*c*，则有 
  $$
  a^2 + b^2=c^2
  $$

- **正弦定理**：这是解决三角形问题时非常有用的定理，它表明在任意三角形中，各边的长度与其对应角的正弦值之比相等。即如果三角形的边长分别为*a*、*b*、*c*，对应的角分别为*A*、*B*、*C*，则有 
  $$
  \frac{a}{\sin A} = \frac{b}{\sin B} = \frac{c}{\sin C}
  $$
  ，其中*R*是三角形外接圆的半径。

- **余弦定理**：在任意三角形中，任意一边的平方等于其他两边的平方和减去两倍的其他两边长度乘以它们夹角的余弦值。即如果三角形的边长分别为*a*、*b*、*c*，对应的角分别为*A*、*B*、*C*，则有 
  $$
  c^2=a^2+b^2-2abcosC
  $$
  。余弦定理在解决非直角三角形的问题中非常有用，尤其是在涉及边长和角度关系的问题中。

- **圆幂定理**：对于任意一点到圆的两条切线，它们的长度是相等的。对于任意一条经过该点的割线，割线的两段长度的乘积是一个常数，这个常数等于该点到圆心的距离的平方减去圆的半径的平方。圆幂定理在解决与圆有关的几何问题中非常有用。

- **切割线定理**（也称为割线-切线定理）：如果一条直线从外部点P切割圆，形成一条切线段*PT*和一条割线段*P**A**B*（A和B是割线与圆的交点），那么
  $$
  PT^2=PA*PB
  $$
  。这个定理在解决圆和直线关系的几何问题中很有帮助。

- **四点共圆**：四点共圆是一个判断四个点是否能在同一个圆上的几何概念。如果四个点*A*、*B*、*C*、*D*满足某种特定的关系，那么它们可以位于同一个圆上。这个概念在解决几何问题时非常重要，尤其是在证明四个点共圆的时候。常用的判断四点共圆的方法包括使用圆的方程、利用角的性质（如对顶角、圆周角等）等。

- **圆锥曲线的几何性质**：圆锥曲线（包括椭圆、双曲线和抛物线）拥有许多独特的几何性质。例如，椭圆的每一点到两个焦点的距离之和是一个常数；双曲线的每一点到两个焦点的距离之差的绝对值是一个常数；抛物线上的每一点到焦点的距离等于该点到准线的距离。

- **圆锥曲线的光学性质**：圆锥曲线的光学性质是指光线在圆锥曲线上的反射和折射特性。例如，椭圆上的任意一点反射到两个焦点的光线路径长度相等；抛物线上的任意一点反射到焦点的光线都平行于对称轴；双曲线上的任意一点反射到一个焦点的光线将经过另一个焦点。

- 圆锥曲线的离心率：圆锥曲线的离心率（eccentricity）是一个非负实数，它描述了圆锥曲线的形状。对于椭圆，离心率*e*满足0⩽*e*<1；对于双曲线，*e*>1；对于抛物线，*e*=1。离心率越小，椭圆越接近圆形；离心率越大，双曲线的两支越开。

#### 1.1.2. 向量表示与坐标变换

在 Python 中我们可以使用 NumPy 库来创建和操作向量，例如：

```python
import numpy as np
x = np.array([1, 2, 3, 5, 8])
# array([1, 2, 3, 5, 8])
```

这样我们便创建了一个向量。随后便可以进行各种操作。

解析几何法的本质就是利用函数与方程来表示不同的几何曲线。在中学阶段我们都学习过圆锥曲线的方程形式，但在实际问题中我们面临的曲线会更加复杂。尤其是在三维空间中的曲线与曲面，可能会用到多元函数去进行表示，也可能用极坐标或参数方程更加方便，但不管怎么说，解析几何方法的本质就是把各种几何问题都转化为代数问题求解。解方程比起复杂的分析，更依靠计算，而这恰恰是程序所擅长的。

在数学中，坐标变换通常涉及到一系列的矩阵运算，这些矩阵描述了一个坐标系相对于另一个坐标系的位置和方向。旋转变换就是其中的一个典型例子。当我们说一个坐标系相对于另一个坐标系进行了旋转，我们通常是指它绕着一个轴或者点旋转了一定的角度。二维空间的旋转可以简化为点绕原点旋转，而三维空间则涉及到更复杂的轴向旋转。

![](G:\笔记\picture\1-1.png)

在二维空间中，如果我们要将坐标系绕原点旋转一个角度，就可以通过旋转矩阵来实现。旋转矩阵是一个非常简单而又强大的工具，它可以将原始坐标系中的点通过线性变换映射到新坐标系中。对于逆时针旋转，二维旋转矩阵的形式是
$$
\left[\matrix{
  \cos \theta & -\sin\theta\\
  \sin \theta & \cos\theta 
}
\right]
$$
这里，*θ*是旋转角度，当应用这个旋转矩阵于一个点(*x*,*y*)，它会给出新的坐标(*x*′,*y*′)，这表示了原始点在新坐标系中的位置。

使用NumPy进行这样的变换非常简单。首先，我们创建一个表示点坐标的NumPy数组，然后创建表示旋转矩阵的二维数组。通过对这两个数组进行点积运算（也就是矩阵乘法），我们就可以得到新的坐标，在Python中可以这样实现：

```python
import numpy as np

# 设定旋转角度，这里我们以30度为例
theta = np.radians(30)  # 将30度转换为弧度

# 创建旋转矩阵
rotation_matrix = np.array([
    [np.cos(theta), -np.sin(theta)],
    [np.sin(theta), np.cos(theta)]
])

# 假设我们有一个点 (a, b)
point = np.array([a, b])

# 通过旋转矩阵变换这个点的坐标
rotated_point = rotation_matrix.dot(point)

print("原坐标为:", point)
print("旋转后的坐标为:", rotated_point)
# 原坐标为: [5 3]
# 旋转后的坐标为: [2.83012702 5.09807621]
```

此示例代码中，旋转角度是预设的，你可以根据实际情况调整。通过这种方式，我们能够将几何问题通过坐标变换转化为代数问题，使用编程方法来进行高效的计算。这不仅仅适用于理论数学问题，同样也适用于工程、物理学、计算机图形学以及机器人技术等多个领域中。

![](G:\笔记\picture\1-2.png)

在三维空间中，物体的旋转可以围绕三个主轴进行：x轴， y轴和z轴。这些轴旋转代表了不同方向的运动，并且可以通过旋转矩阵来数学描述。例如，一个点*P*(*x*,*y*,*z*)绕z轴旋转角度*α*可以表示为
$$
R_Z(\alpha) = 
\left[\matrix{
	\cos \alpha & -\sin\alpha & 0\\
	\sin\alpha & \cos\alpha&0\\
	0 & 0 & 1
}
\right]
$$
这个旋转保持z坐标不变，同时*X* *Y*平面上变换x和y坐标。相似地，点*P*绕y轴旋转角度*β*的旋转矩阵为
$$
R_y(\beta) = 
\left[\matrix{
	\cos \beta & 0 & \sin\beta\\
	0 & 1 & 0\\
	-\sin\beta &0& \cos\beta
}
\right]
$$
这个旋转保持yy坐标不变，同时在XZ*XZ*平面上变换xx和zz坐标。而点P*P*绕xx轴旋转角度γ*γ*的旋转矩阵为
$$
R_y(\beta) = 
\left[\matrix{
	1&0&0\\
	0&\cos\gamma&-\sin\gamma\\
	0&\sin\gamma&\cos\gamma
}
\right]
$$
这个旋转保持xx坐标不变，同时在*Y* *Z*平面上变换y和z坐标。若点*P*需同时围绕三个轴旋转，则最终旋转矩阵R*R*为这三个矩阵的乘积，即
$$
R=R_z(\alpha)R_y(\beta)R_x(\gamma)
$$
。需要注意的是，由于矩阵乘法的非交换性，旋转的顺序会影响最终结果。

在实际应用中，如机器人学、航空航天和计算机图形学，旋转顺序对于模拟和预测物体如何移动至关重要。例如，飞机的姿态控制就极依赖于绕不同轴的旋转顺序，以精确地模拟和控制飞机的行动。在三维建模和动画制作中，这些旋转变换同样是创建动态、逼真场景的基础。

在Python中，利用NumPy库，我们可以使用如下代码片段来实现三维旋转变换：

```python
import numpy as np

# 定义欧拉角（以弧度为单位）
alpha = np.radians(30)  # 绕 z 轴的 Yaw 角度
beta = np.radians(45)   # 绕 y 轴的 Pitch 角度
gamma = np.radians(60)  # 绕 x 轴的 Roll 角度

# 构建对应的旋转矩阵
R_z = np.array([[np.cos(alpha), -np.sin(alpha), 0],
                [np.sin(alpha), np.cos(alpha), 0],
                [0, 0, 1]])
R_y = np.array([[np.cos(beta), 0, np.sin(beta)],
                [0, 1, 0],
                [-np.sin(beta), 0, np.cos(beta)]])
R_x = np.array([[1, 0, 0],
                [0, np.cos(gamma), -np.sin(gamma)],
                [0, np.sin(gamma), np.cos(gamma)]])

# 总旋转矩阵，注意乘法的顺序
R = np.dot(R_x, np.dot(R_y, R_z))

print("组合旋转矩阵为:")
print(R)
# 组合旋转矩阵为:
# [[ 0.61237244 -0.35355339  0.70710678]
#  [ 0.78033009  0.12682648 -0.61237244]
#  [ 0.12682648  0.9267767   0.35355339]]
```

当你运行这段代码，它会打印出综合所有三次旋转的旋转矩阵R。

### 1.2. Numpy与线性代数

在本节中，我们将探讨Python中最强大的科学计算库之一：NumPy。在深入学习之前，我们需要弄清楚线性代数在实际应用中的重要性。线性代数不仅是理解数据结构、解决数学问题的基础，也是计算机图形学、机器学习等高级领域不可或缺的工具。NumPy库在这里扮演了至关重要的角色，因为它为我们提供了一个高效、便捷的平台来处理数值计算和线性代数运算。接下来的内容，将通过实际的例子展示如何使用NumPy来执行一些基础但强大的线性代数操作。

#### 1.2.1. Numpy向量与矩阵的操作

在科学计算的世界里，NumPy的数组对象是我们解决问题的得力助手。它能让我们轻松地执行向量化运算，这意味着可以一次性处理数据集而不需要使用循环。这种处理方式不仅代码更加简洁，而且运行速度也远快于传统的Python循环。在Numpy中，向量和矩阵都可以用二维数组表示，让我们来看看基本操作。

**创建向量和矩阵**

```python
import numpy as np
# 创建向量
vector = np.array([1, 2, 3])
# 创建矩阵
matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

```

**向量和矩阵的基本属性**

```python
# 向量的维度
print(vector.shape) # (3, )
# 矩阵的维度
print(matrix.shape) # (3, 3)
# 矩阵的行数和列数
print(matrix.shape[0])  # 行数, 3
print(matrix.shape[1])  # 列数, 3Copy to clipboardErrorCopied
```

**索引和切片**

```python
# 索引
print(vector[0])  # 输出第一个元素, 1
print(matrix[1, 1])  # 输出第二行第二列的元素, 5

# 切片
print(vector[0:2])  # 输出前两个元素, [1, 2]
print(matrix[0:2, 0:2])  # 输出左上角的2x2子矩阵, [[1, 2], [4, 5]]Copy to clipboardErrorCopied
```

**向量和矩阵的运算**

```python
# 向量加法
vector1 = np.array([1, 2, 3])
vector2 = np.array([4, 5, 6])
print(np.add(vector1, vector2))
# [5, 7, 9]

# 矩阵乘法
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
print(np.dot(matrix1, matrix2))  # 或使用 matrix1 @ matrix2
# [[19, 22],
#  [43, 50]]Copy to clipboardErrorCopied
```

#### 1.2.2. 利用Numpy进行线性代数基本运算

在NumPy中，我们可以利用数组的**广播机制**来进行各种线性代数运算。例如，你可以轻松地将一个标量与一个向量或矩阵相乘，而不需要编写任何循环。NumPy也提供了计算矩阵的转置、行列式、逆矩阵等常见操作的函数。

```python
import numpy as np

# 数量乘法示例
scalar = 5
scaled_vector = scalar * vector
print("Scaled vector:", scaled_vector)
# Scaled vector: [ 5 10 15]

# 矩阵的转置示例
transposed_matrix = matrix.T
print("Transposed matrix:\n", transposed_matrix)
# Transposed matrix:
# [[1, 4, 7]
#  [2, 5, 8]
#  [3, 6, 9]]

# 计算行列式示例
matrix_determinant = np.linalg.det(matrix)
print("Matrix determinant:", matrix_determinant)
# Matrix determinant: 0.0

# 求解线性方程组示例
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])
solution = np.linalg.solve(A, b)
print("Solution of the linear system:", solution)
# Solution of the linear system: [2. 3.]
Copy to clipboardErrorCopied
```

#### 1.2.3. numpy.linalg 的使用

最后，我们不能不提NumPy中的 `linalg` 子模块，它包含了一系列关于线性代数的函数。无论是求解方程组，还是计算特征值、特征向量，乃至执行奇异值分解，`linalg` 模块都能够提供帮助。通过这些工具，我们可以探索矩阵的深层属性，并应用于各种数学和工程问题。下面是一些 `numpy.linalg` 模块的使用示例：

**计算逆矩阵**

```python
import numpy as np
# If the matrix is singular, use the pseudo-inverse
pseudo_inverse_matrix = np.linalg.pinv(matrix)
print("Pseudo-inverse of the matrix:")
print(pseudo_inverse_matrix)
# Pseudo-inverse of the matrix:
# [[-6.38888889e-01 -1.66666667e-01  3.05555556e-01]
#  [-5.55555556e-02  4.20756436e-17  5.55555556e-02]
#  [ 5.27777778e-01  1.66666667e-01 -1.94444444e-01]]
Copy to clipboardErrorCopied
```

**特征值和特征向量**

```python
eigenvalues, eigenvectors = np.linalg.eig(matrix)
print(eigenvalues)
# [ 1.61168440e+01 -1.11684397e+00 -1.30367773e-15]

print(eigenvectors)
# [[-0.23197069 -0.78583024  0.40824829]
#  [-0.52532209 -0.08675134 -0.81649658]
#  [-0.8186735   0.61232756  0.40824829]]
Copy to clipboardErrorCopied
```

**奇异值分解**

```python
U, S, V = np.linalg.svd(matrix)
print(U)
# [[-0.21483724  0.88723069  0.40824829]
#  [-0.52058739  0.24964395 -0.81649658]
#  [-0.82633754 -0.38794278  0.40824829]]

print(S)
# [1.68481034e+01 1.06836951e+00 4.41842475e-16]

print(V)
# [[-0.47967118 -0.57236779 -0.66506441]
#  [-0.77669099 -0.07568647  0.62531805]
#  [-0.40824829  0.81649658 -0.40824829]]
Copy to clipboardErrorCopied
```

> 在np的计算中存在浮点数误差，特征向量形成矩阵转置乘以特征向量形成矩阵并不完全等于单位矩阵，故按步骤计算和直接调用函数存在一定误差。感谢学习者提问，这里回答一下。

**范数计算**

```python
norm = np.linalg.norm(vector)
print(norm)
# 3.7416573867739413
```

### 1.5. 使用Python解方程与方程组

在科学计算和工程应用中，经常会遇到需要求解方程或方程组的问题。Python提供了强大的数学库，如Numpy和Sympy，可以帮助我们轻松地解决这些问题。

#### 1.5.1. 利用Numpy求线性方程（组）的数值解

Numpy是Python中一个用于数值计算的库，它提供了很多用于矩阵运算的功能。我们可以使用Numpy中的linalg.solve函数来解线性方程组。例如，我们有以下方程组：
$$
10x - y - 2a = 72,\\
-x+10y-2z=83,\\
-x-y+5z=42.
$$
我们可以使用以下代码来求解这个方程组：

```python
import numpy as np
a = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]])
b = np.array([[72], [83], [42]])
c = np.linalg.solve(a, b)
print(c)
#[[11.]
# [12.]
# [13.]]

此外，我们还可以使用矩阵的逆来求解方程组，即：
x = np.linalg.inv(a).dot(b)
print(x)
# [[11.]
# [12.]
# [13.]]
```

#### 1.5.2. 利用Sympy求方程（组）的解析解

Sympy是python中一个用于符号计算的库，它可以提供方程的解析解，而不仅仅是数值解。什么是解析解和数值解呢？简单来说，解析解是指用数学符号（如x*x*、y*y*、π*π*等）表示的解，而数值解是指用具体的数字表示的解。

在Sympy中，我们首先需要创建符号变量，然后使用 `solve` 函数来求解方程或方程组。例如：

```python
from sympy import symbols, solve, nonlinsolve

x, y = symbols('x y')
print(solve(x * 2 - 2, x))  # 解方程2x - 2 = 0
# [1]

print(solve([x + y - 35, x * 2 + y * 4 - 94], x, y))  # 解方程组x + y = 35, 2x + 4y = 94
# {x:23, y:12}

print(solve(x**2 + x - 20, x))  # 解方程x^2 + x - 20 = 0
# [-5, 4]

a, b, c, d = symbols('a b c d', real=True)
print(nonlinsolve([a**2 + a + b, a - b], [a, b]))  # 解非线性方程组a^2 + a + b = 0, a - b = 0
# {(-2, -2), (0, 0)}
```

以下是一个具体案例：

![Pasted_image_20240417124525](G:\笔记\picture\Pasted_image_20240417124525.png)

图12 平面型Stewart平台示意图

图12给出的是平面型Stewart平台示意图，它模拟一个操作装置，其中包括一个三角形(*ABC*)平台，平台位于一个由3个支柱(*P*1, *P*2和*P*3)控制的固定平面中。图中的三角形(*ABC*)表示平面型Stewart平台，它的尺寸由3个长度*L*1，*L*2，*L*3确定。平台的位置由3个支柱的可变长度的3个参数*P*1，*P*2，*P*3所控制。需要解决的问题是，在给定一组参数*P*1，*P*2，*P*3的值后，计算出A*A*点的坐标(*x*,*y*)和角度θ*θ*的值(*θ*是*L*3与*x*轴的夹角)。请你完成：

1. 数学建模：参数*L*1,*L*2,*L*3,*x*1,*x*2,*y*2是固定常数，在给定一组参数*P*1,*P*2,*P*3的值后，判断能否得到Stewart平台的一个位置，即能否得到A*A*点坐标(*x*,*y*)和角度*θ*的值。如果能，则称它为Stewart平台的一个**位姿**。但位姿并不一定是唯一的，如何让你的模型能够计算出一组固定参数下的全部位姿。
2. 模型检验：假设有如下参数: *x*1=5, (*x*2,*y*2)=(0,6)，*L*1=*L*3=3, *L*2=3, *p*1=*p*2=5, *p*3=3，请根据你的模型，计算出Stewart平台的全部位姿，即计算出每个Stewart平台中的*A*点坐标(*x*,*y*)和角度*θ*的值。

**定义问题的几何关系**

*A*点的坐标：由于*A*点位于支柱*P*1的顶端，我们可以使用距离公式确定*A*点的坐标。这是一个圆的方程，表示所有与原点距离为*P*1的点集合。方程如下：
$$
x^2+y^2=P_1^2
$$
角度*β*的计算：角度*ΔABC*的内角，根据余弦定理，我们有：
$$
\cos\beta=\frac{L_2^2+L_3^2-L_1^2}{2L_2L_3}
$$
*B*点的坐标：*B*点相对于*A*点的位置可以用角度*θ*表示，根据*A*点的坐标和角度*θ*，我们可以写出*B*点的坐标
$$
B(x_B,y_B) = (x + L^3\cos\theta, y + L^3\sin\theta)
$$
*C*点的坐标：同样地，*C*点相对于*A*点的位置可以用角度*β*+*θ*来确定，于是*C*点的坐标为：
$$
C(x_C,y_C)=(x+L^2\cos(\beta+\theta), y+L^2\sin(\beta + \theta))
$$
**建立方程组**

*B*点与*P*2的距离关系：由于*B*点还位于支柱的顶端，所以我们有第二个方程：
$$
(x_B-x_1)^2+y_B^2=P_2^2
$$
*C*点与*P*3的距离关系：同理，*C*点位于支柱的顶端，所以我们有第三个方程：
$$
(x_C-x_2)^2+(y_C-y_2)^2=P_3^2
$$
**解方程组以确定A点坐标和角度θ**

- 方程求解：我们现在有三个方程和两个未知数 *x* 和 *y*。为了求解 *x* 和 *y*，我们可以用任何一个方程消去 后解一个二元一次方程组。
- 多解的情况：这组方程可能有多个解，对应于不同的物理位置和Stewart平台的不同位姿。
- 数值求解：在实践中，通常需要通过数值方法来解这类方程组，例如使用牛顿法或者数值优化算法。
- 模型检验：给定的参数 *x*1=5, (*x*2,*y*2)=(0,6)，*L*1=*L*3=3, *L*2=3, *p*1=*p*2=5, *p*3=3 可以代入上述方程组中进行求解。这将验证模型的正确性，并给出所有可能的Stewart平台位姿。

通过上述步骤，我们不仅可以找到*A*点的坐标和角度*θ* ，而且还可以确定Stewart平台的多个可能位姿，这些位姿对应于不同的解集。这是一个典型的运动学问题，其解决方案涉及几何、三角函数以及数值计算。

#### 1.5.3. 利用Scipy方程（组）的数值解

在进行数值求解时，`fsolve` 是 Scipy 库中用于解决非线性方程组的一个非常有用的函数。它通常用于查找方程组的根，其中方程组可以是非线性的，并且不保证有解析解。接下来我们将会对1.5.2小节例题进行求解。

首先，尝试使用 Sympy 库解方程组时，我们发现问题无法解决。这是因为所面临的方程组可能没有简洁的解析解，或者是解析解超出了Sympy库的计算范围。以下是尝试解方程的代码和得到的结果：

```python
from sympy import symbols, cos, sin, pi, nonlinsolve
import numpy as np
x, y, theta = symbols('x y theta', real=True)
L1, L2, L3 = 3, 3, 3
p1, p2, p3 = 5, 5, 3
x1, x2, y2 = 5, 0, 6
# 计算内角β
b = np.arccos((L2**2 + L3**2 - L1**2) / (2 * L2 * L3))
print(b)
# 尝试解方程组
solution = nonlinsolve([
    (x + L3 * cos(theta) - x1)**2 + (y + L3 * sin(theta))**2 - p1**2,
    x**2 + y**2 - p2**2,
    (x + L2 * cos(pi/3 + theta))**2 + (y + L2 * sin(pi/3 + theta) - y2)**2 - p3**2
], [x, y, theta])
print(solution)
# 1.0471975511965979
```

得到的输出表明，我们没有找到方程组的解析解。在这种情况下，我们转向数值解法，特别是Scipy库中的`fsolve`函数，来找到方程组的数值解。以下是使用`fsolve`的案例：

执行以上代码，我们得到了方程组的一组数值解。

上面的代码中，`equations` 函数定义了一个方程组，它接受一个变量列表（在这里是 `x`, `y`, 和 `theta`），然后返回一个方程组列表。然后，我们使用 `fsolve` 来求解这个方程组，并且提供了一个初始猜测值列表 `initial_guess`。`fsolve` 会尝试找到这些方程的根，这意味着它会寻找满足方程组为零的 `x`, `y`, 和 `theta` 的值。

在 Scipy 库中，除了 `fsolve`，还有其他几个函数可以用于解决类似的问题，比如：

- `brentq` 或 `bisection`：这些函数是用于求解单变量方程的根的，适用于在指定区间内具有一个根的情况。
- `root`：这个函数提供了一个更加通用的接口来求解多变量方程组的根，它允许选择不同的算法，比如 `hybr`, `lm`, `broyden1`, 等等。
- `newton`：用于求解单变量方程的根，当你有方程的导数信息时特别有用。

对于复杂的方程组，尤其是当没有解析解时，使用数值方法通常是解决问题的可行方式。**在使用数值方法时，很重要的一点是要有一个合理的初始猜测，因为这些方法很大程度上依赖于起始点，并且可能收敛到局部解，或者在某些情况下可能根本不收敛。**

### 本章小结

本章是数学建模的一个导引章节。在这一章节中，我们一起探索了几何模型在数学建模中的基础应用和实际操作。从向量表示法的初步了解到复杂立体几何模型的构建，再到运用Python编程语言中的 Numpy、Sympy、Scipy 等库求解方程和方程组，我们一步步深入了解了几何模型的精髓。

我们首先回顾了几何建模的基本思想，并探讨了向量表示和坐标变换的重要性。这不仅巩固了我们的几何基础知识，也为后续的学习打下了坚实的基础。接着，通过Numpy的强大功能，我们学习了线性代数中向量与矩阵的操作，以及如何运用Numpy.linalg库来进行基本的线性代数运算。

随后，我们针对平面几何模型和立体几何模型分别进行了深入的分析和建模。在每个问题中，我们不仅建立了数学模型，还通过模型的求解与讨论，实践了数学建模的全过程，这无疑增强了我们解决实际问题的能力。

在使用Python解方程与方程组的部分，我们学习了如何利用不同的Python库来解决具体的数学问题。这些内容不仅仅是理论上的，更多的是实践操作，让我们在解决实际问题时更加得心应手。

作为本章的结束，希望大家不仅理解了几何模型的构建方法，而且能够领会背后的数学原理，并将这些知识应用到现实生活中去。在接下来的章节中，我们将进一步学习更多高级的数学建模技巧和方法。请大家继续保持好奇心和探索精神，相信在数学建模的道路上会有更多的发现和成就。

祝愿各位读者在学习的旅途中收获知识，享受创造的乐趣，不断提升自己的问题解决能力。在这个以数据和模型驱动的时代，让我们共同成长为理解世界的数学建模者。

## 2. 微分方程与动力系统

这一章我们主要介绍微分方程与一些动力系统模型。数学上对微分方程的研究是一项热点问题，在工程当中微分方程与动力系统也有着广泛的应用。我们除了会从高等数学与计算数值方法的角度分析微分方程的求解方法与底层逻辑，还会介绍在数学模型当中被广泛应用的微分方程模型。本章主要涉及到的知识点有：

- 微分方程的解法
- 如何用python解微分方程
- 偏微分方程及其求解方法
- 微分方程的基本案例
- 差分方程的求解
- 数值计算方法
- 元胞自动机

注意：本章的重点是理解微分方程在实际工程中的应用。如果对数学基础有疑问，可以参考相关的高等数学和数值分析教材。

### 2.1. 微分方程的理论基础

微分方程是什么？如果你参加过高考，可能在高三备考中遇到过这样的问题：给定函数*f*(*x*)及其导数之间的等式，然后分析函数的性质，如单调性、零点等，但没有给出函数的解析式。这时你可能会想，如果能通过这个方程求出函数的通项形式该多好！微分方程的目的就是这样，它通过将函数*f*和它的若干阶导数联系起来形成一个方程（组），来求出函数的解析式或函数值随自变量变化的曲线。

#### 2.1.1. 函数、导数与微分

微分和导数其实是紧密相关的概念。我们通常将导数理解为函数在某一点处切线的斜率。而微分则描述的是当我们对自变量x施加一个非常小的增量d*x*时，函数值相应的变化量与d*x*之间的关系。当d*x*非常小的时候，函数的变化量就接近于在该点处切线的变化量d*y*。因此，我们可以用这种方式来理解微分：
$$
\frac{dy}{dx} = f^`(x)
$$
在图2.1.1中，我们展示了函数、导数和微分之间的关系。微分实际上描述的是点*M*处切线的斜率；导数则描述的是割线*MN*的斜率。但当d*x*足够小的时候，切线的斜率和割线的斜率就会非常接近，这就是微分的核心概念。而微分方程，就是描述函数与其导数之间关系的方程。

![Pasted_image_20240423220303](G:\笔记\picture\Pasted_image_20240423220303.png)

相对于求微分，我们还有求积分的概念。积分本质上是根据已知的导数反推出原函数，这就是不定积分。而定积分则是在反推出原函数后，还需要计算该函数在特定区间内的值的差异。通常情况下，我们可以通过查阅常见函数的导数表来进行微分和不定积分的计算。

> 注意：割线斜率等于切线斜率的前提是dx非常小，这是一种极限思想的体现。虽然它们之间存在一个无穷小量PN的差距，但当我们在考虑dx时，这种差异就可以忽略不计了。这就是微分和积分的基本思想。

#### 2.1.2. 一阶线性微分方程的解

一阶线性微分方程描述的是怎么一回事呢？它是指形如下方的方程：
$$
\frac{dy}{dX} + yP(x) = Q(X)
$$
这里的*y*是一个未知函数，而*P*和*Q*是已知的函数。我们的目标是找出*y*的解，即它的通解形式。为了解这个方程，我们通常会使用分离变量积分法和常数变易法这两种方法。首先，我们尝试解一个特殊情况的齐次方程，即当*Q*(*x*)=0时：
$$
\frac{dy}{dx}+yP(x)=0
$$
通过变量分离和变形，我们可以得到：
$$
\frac{1}{y}dy=P(x)dx
$$
接着，对两边进行不定积分，我们可以得到解的通式为
$$
y=C\exp \{-\int P(x)dx\}，
$$
其中*C*是一个常数。但在一般情况下，*Q*(*x*)不一定为0，所以我们需要将常数*C*替换为一个函数*C*(*x*)，然后对*y*求导并将其代入原方程中以求得*C*(*x*)的通解。这就是所谓的常数变易法。有兴趣的读者可以进一步推导出方程的通解为（其中*C*为常数）：
$$
y=\exp\{-\int P(x)dx\}[\int Q(x)\exp \{\int P(X)dx\}dx + C].
$$

> 注意：这里的定积分符号用于求原函数。这就是为什么我们在高中学习的积分符号应该按照这种方式书写的原因。齐次方程指的是方程右边等于0的情况，而非齐次方程则是方程右边不恒等于0的情况。解非齐次方程更具有一般性，但很多非齐次方程的解也是基于齐次方程的解进行拓展的。

#### 2.1.3. 二阶常系数线性微分方程的解

二阶常系数线性微分方程可以表示为：
$$
f^{``}(x) + pf^`(x)+qf(x) = C(x)
$$
这个方程关联了二阶导数、一阶导数和函数本身。解决这个方程的一般策略是先考虑对应的齐次方程，即让*C*(*x*)为0：
$$
f^{``}(x)+pf^`(x)+qf(x)=0
$$
解这种二阶常系数齐次线性微分方程时，我们通常使用特征根法。这个方法的关键是求解特征方程：
$$
r^2+pr+q=0
$$
这个齐次方程的解的形式取决于特征方程的根。根据特征方程的不同实根、相同实根、或共轭复根，齐次微分方程的解会有不同的形式：
$$
\begin{cases}
	y = C_1e^{\alpha_1x} + C2e^{\alpha_2x},\space\space\space\space r_1=\alpha_1,r_2=\alpha_2(1)\\
	y=(C_1x+C_2)e^{\alpha x},\space\space\space\space r_1=r_2=\alpha(2)\\
    y=e^{\alpha x}[C_1\sin(\beta x)+C_2\cos(\beta x)].\space\space\space\space r=\alpha \pm \beta i(3)
\end{cases}
$$

> 注意：这里可能有些读者不太明白为什么二次方程的根与齐次方程的解之间会有联系，这正是数学之美的体现之一。如果想检验这个方程的解是否正确，实际上并不难，可以使用 Vieta 定理将 *p* 和 *q* 代入，将两个方程统一起来，再通过换元法将其降为一阶微分方程进行验证。

对于一般的二阶非齐次线性微分方程，我们可以根据右侧*C*(*x*)的形式推导出一个特解。非齐次方程的通解等于齐次方程的通解加上非齐次方程的特解。求微分方程的特解有时需要观察法，但幸运的是，存在两种特殊形式：
$$
C(x)=P_m(x)e^{\lambda x},\\
C(x)=e^{\lambda x}[P_m\cos (\omega x)+Q_n(x)\sin(\omega x)]
$$
其中 *P* *m*(*x*)是一个m*m*次多项式，*Q* *n*(*x*)是一个*n*次多项式。这两种形式的特解分别为：
$$
f(x)=x_kP_m(x)e^{\lambda x},\\
f(x)=x^ke^\lambda x[P_i\cos(\omega x) + Q_i(x)\sin(\omega x)].\space\space\space\space i=\max\{m, n\}
$$
其中*k*的取值取决于特征方程根的个数：如果有两个不同的实根，则*k*=2；如果有两个相同的实根，则*k*=1；如果没有实根，则*k*=0。通过上述形式，我们可以解出二阶线性微分方程。

特征根法和“特解+通解”的策略不仅适用于二阶线性微分方程，也适用于一般的高阶线性微分方程。只要特征方程是多项式，它至少满足韦达定理。在后续的差分方程中，特征根法同样会发挥重要作用。

#### 2.1.4. 利用Python求函数的微分与积分

在Python中，我们可以使用Numpy和SciPy这两个库来进行函数的微分和积分计算。下面将通过具体示例来说明如何使用这些库来求解函数的微分和积分。 假设我们需要计算函数`f(x) = cos(2πx) * exp(-x) + 1.2`在区间`[0, 0.7]`上的定积分。我们可以使用SciPy库中的`quad`函数来完成这个任务：

```python
import numpy as np
from scipy.integrate import quad
# 定义函数
def f(x):
    return np.cos(2 * np.pi * x) * np.exp(-x) + 1.2
# 计算定积分
integral, error = quad(f, 0, 0.7)
print(f'定积分的结果是：{integral}')
# 定积分的结果是：0.7951866427656943 
```

除了使用SciPy库中的`quad`函数求解定积分外，我们还可以使用数值积分的方法来近似计算。一种常见的数值积分方法是梯形法则。下面我们将通过一个示例来说明如何使用梯形法则来近似计算函数的定积分。 假设我们需要计算函数`f(x) = cos(2πx) * exp(-x) + 1.2`在区间`[0, 0.7]`上的定积分。我们可以使用梯形法则来近似求解：

```python
h=x[1]-x[0]
xn=0.7
s=0
for i in range(1000):
    xn1=xn+h
    yn=np.cos(2*np.pi*xn)*np.exp(-xn)+1.2
    yn1=np.cos(2*np.pi*xn1)*np.exp(-xn1)+1.2
    s0=(yn+yn1)*h/2
    s+=s0
    xn=xn1
s
# 24.31183595181452
```

对于函数的微分，我们可以使用Numpy库中的`gradient`函数来近似求解。例如，我们想要求解函数`f(x) = x^2`在点`x = 1`处的导数：

```python
import numpy as np
# 定义x的取值范围和步长
x = np.linspace(0, 2, 100)
y = x**2
# 计算导数
dydx = np.gradient(y, x)
# 在x=1处的导数值
derivative_at_1 = dydx[np.argmin(abs(x - 1))]
print(f'在x=1处的导数值是：{derivative_at_1}')
# 在x=1处的导数值是：1.9797979797979792
```

以上示例展示了如何在Python中求解函数的积分和微分。在实际应用中，可以根据具体问题调整函数表达式、积分区间和微分点等参数。

### 2.2. 使用Scipy和Sympy解微分方程

前面我们见过了求微分方程解析解的一些方法，我们知道，微分方程的解本质上是通过给定函数与微分之间的关系求解出函数的表达式。但是事实上，大多数微分方程是没有解析解的，也就是无法求解出函数的具体解析式。这是不是意味着这样的微分方程不可解呢？也不尽然。在上一章中我们已经见过了，以前我们难以求解的超越方程也是可能给出数值解的，那么微分方程是否也会存在数值解呢？

#### 2.2.1 使用sympy求解微分方程解析解

我们此前介绍的一阶、二阶常系数线性微分方程通解的形式就是一种解析解，但在科学与工程实际中我们遇到的微分方程形式会比这些基本形式更为复杂，条件也更多。事实上多数情况下，大多数微分方程其实是求不出解析解的，只能在不同取值条件下求一个数值解。那么如何编写算法去求数值解才能使精度尽可能提高呢？数值解会随着初始条件而变化，怎么变化呢？函数值又与自变量之间怎么变化呢？

在回答这些问题之前，请让我们先了解一番：如何使用python求解微分方程的解析解呢？但凡涉及到符号运算，通常都是使用sympy库实现。Sympy是一个数学符号运算库。能解决积分、微分方程等各种数学运算方法，用起来也是很简单，效果可以和Matlab媲美。其中内置的Sympy.dsolve方法是解微分方程解析解的一种良好方式，而对于有初始值的微分方程问题，我们通常在求出其通解形式后通过解方程组的方法得到参数。这个方法通过声明符号变量的方式求得最优解。

例如，我们看下面这个例子： **例2.1** 使用sympy解下面这个微分方程：
$$
y^{''} + 2y^{'}+y=x^2.
$$
若使用sympy，我们首先要声明两个符号变量，其中变量`y`是变量`x`的函数。代码如下：

```python
from sympy import *
y = symbols('y', cls=Function)
x = symbols('x')
eq = Eq(y(x).diff(x,2)+2*y(x).diff(x,1)+y(x), x*x)
## y''+4y'+29y=0
print(dsolve(eq, y(x)))
```

这段代码通过sympy中的`symbols`类创建两个实例化的符号变量`x`和`y`，在`y`中我们通过`cls`参数声明`y`是一个`scipy.Function`对象（也就是说，`y`是一个函数）。表达微分方程解析解的方法是通过创建一个`Eq`对象，这个对象分别存储方程左右两边。其中，`y(x).diff(x,2)`表明`y`是`x`的函数，然后需要取函数对`x`的2阶导数。最后，若想求解函数`y`的解析式，只需要调用`dsolve(eq,y(x))`函数即可。代码返回结果：

```python
Eq(y(x), x**2 - 4*x + (C1 + C2*x)*exp(-x) + 6)
```

可以看到，代码能够给出完整的解析式。之所以还保留了参数`C1`和`C2`是因为在求解过程中没有给微分方程指定初值。

我们再来看一个例子，这个例子是使用sympy解一个常微分方程组：

**例2.2** 使用sympy解下面这个常微分方程组：
$$
\begin{cases}\frac{dx_1}{dt}=2x_1-3x_2+3x_3,\space\space\space\space x_1(0)=1(6)\\ \frac{dx_2}{dt}=4x_1-5x_2+3x_3,\space\space\space\space x2(0)=2(7)\\ \frac{dx_3}{dt}=4x_1-4x_2+2x_3,\space\space\space\space x3(0)=3(8) \end{cases}
$$
这个方程组里面的x1,x2,x3*x*1,*x*2,*x*3都是关于t*t*的函数，所以需要声明四个符号变量。不同的是，在这里每个函数都指定了初始值，并且三个函数的导数高度相关，该怎么描述这种相关呢？我们来看下面的例子：

```python
t=symbols('t')
x1,x2,x3=symbols('x1,x2,x3',cls=Function)
eq=[x1(t).diff(t)-2*x1(t)+3*x2(t)-3*x3(t),
    x2(t).diff(t)-4*x1(t)+5*x2(t)-3*x3(t),
    x3(t).diff(t)-4*x1(t)+4*x2(t)-2*x3(t)]
con={x1(0):1, x2(0):2, x3(0):3}
s=dsolve(eq,ics=con)
print(s)
```

sympy当中内置的`symbols`工具是可以通过字符串批量创建变量的，这为我们带来了很大的方便。如果需要求解的是一个方程组，则使用列表将每一个方程表达出来即可。这里我们采取了不创建对象的方式，而是直接将方程组移项使每个方程右侧都为`0`。通过字典的方式保存函数的初始值，并利用`ics`参数传入`dsolve`从而得到方程的解。

```python
[Eq(x1(t), 2*exp(2*t) - exp(-t)), Eq(x2(t), 2*exp(2*t) - exp(-t) + exp(-2*t)), Eq(x3(t), 2*exp(2*t) + exp(-2*t))]
```

结果返回的是一个`Eq`对象构成的列表，每个对象代表了一个函数的解析式。对于这个例子，大家可以发现：它是一个线性的微分方程组，而针对线性方程我们还可以使用矩阵的形式去表示。所以，这个问题还有第二种写法：

```python
x=Matrix([x1(t),x2(t),x3(t)])
A=Matrix([[2,-3,3],[4,-5,3],[4,-4,2]])
eq=x.diff(t)-A*x
s=dsolve(eq,ics={x1(0):1, x2(0):2, x3(0):3})
print(s)
```

通过sympy中内置的符号矩阵`Matrix`对象构造函数向量和系数矩阵，通过对方程组矩阵化也可以得出一样的结果。返回值同上。使用sympy中的符号函数绘图得到结果如下：

```python
from sympy.plotting import plot
from sympy import *
t=Symbol('t')
plot(2*exp(2*t) - exp(-t), line_color='red')
plot(2*exp(2*t) - exp(-t) + exp(-2*t), line_color='blue')
plot(2*exp(2*t) + exp(-2*t), line_color='green')
```

![img](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423223752.png)

图2.1.2 sympy求解图

sympy通过plotting下面的plot功能可以进行一些符号函数的绘图，但每一次调用都会创建一个独立的图窗，难以在同一张图上绘制多个函数的曲线。若要绘制多个函数则需要使用matplotlib来完成。

#### 2.2.2 使用scipy求解微分方程数值解

微分方程的数值解是什么样子的呢？虽然大多数微分方程没有解析解，但解析式也并不是唯一可以表示函数的形式。函数的表示还可以用列表法和作图法来表示，而微分方程的数值解也正是像列表一样针对自变量数组中的每一个取值给出相对精确的因变量值。

Python求解微分方程数值解可以使用scipy库中的`integrate`包。在这当中有两个重要的函数：`odeint`和`solve_ivp`。但本质上，从底层来讲求解微分方程数值解的核心原理都是Euler 法和Runge-Kutta 法。关于这两个方法，我们会在后面进行进一步探讨。

我们先来了解一下`odeint`的用法吧。`odeint()`函数需要至少三个变量，第一个是微分方程函数，第二个是微分方程初值，第三个是微分的自变量。为了具体了解它的用法，我们通过一个例子来分析：

**例2.3** 使用scipy解下面这个微分方程的数值解：
$$
y^{'}=\frac{1}{1 + x^2}-2y^2,\space\space\space\space y(0)=0.
$$
首先需要通过`def`语句或者`lambda`表达式定义微分方程的表达式，然后定义微分方程的初值。代码如下：

```python
import matplotlib.pyplot as plt
dy=lambda y,x: 1/(1+x**2)-2*y**2 # y'=1/(1+x^2)-2y^2
'''
def dy(y,x):
    return 1/(1+x**2)-2*y**2
'''
x=np.arange(0,10.5,0.1) #从0开始，每次增加0.1，到10.5为止（取不到10.5）
sol=odeint(dy,0,x) # odeint输入：微分方程dy，y的首项（y(0)等于多少），自变量列表
print("x={}\n对应的数值解y={}".format(x,sol.T))
plt.plot(x,sol)
plt.show()
```

这里`odeint`函数传入的三个参数分别是函数表达式，函数的初值与自变量。自变量是一个数组，通过`numpy.arange`生成一个范围在`[0, 10.5)`的等差数列，公差为`0.1`。返回的结果`sol`是针对数组`x`中每个值的对应函数值，可以通过`matplotlib.pyplot`绘图得到函数的结果。函数的图像如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423224135.png)

图2.2.1 odeint函数求解图

我们再来看一个例子，这个例子是一个不可积函数的积分问题：

**例2.4** 使用scipy解下面这个微分方程的数值解：
$$
y^{'}=\sin t^2,\space\space\space\space y(0) = 1
$$
仿照例2.3中的代码，这个问题可以改写为：

```python
def dy_dt(y,t):
    return np.sin(t**2)
y0=[1]
t = np.arange(-10,10,0.01)
y=odeint(dy_dt,y0,t)
plt.plot(t, y)
plt.show()
```

得到的结果必然是一个奇函数，图像为：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423224303.png)

图2.2.2 scipy函数求解图

刚刚两个例子都是讲述了一阶微分方程如何求解，那么二阶及以上的高阶微分方程如何求解呢？事实上，Python求解微分方程数值解的时候是无法直接求解高阶微分方程的，必须通过换元降次的方法实现低阶化，把一个高阶微分方程替换成若干个一阶微分方程组成的微分方程组才能求解。具体的，我们可以看下面这个例子：

**例2.5** 使用scipy解下面这个高阶微分方程的数值解：
$$
y^{''}-20(1-y^2)y^{'}+y=0, \space\space\space\space y(0)=0,y^{'}(0)=2
$$
这很显然是个二阶微分方程，并且不是常系数所以不能直接给出解析解。为了给这个方程做降次，令*u*=*y*′，那么*y*′′=*u*′，式子就可以代换为：
$$
\begin{cases} u=y^{'},(9)\\ u^{'}-20(1-y^2)u+y=0,(10)\\ y(0)=0,(11)\\ u(0)=2.(12) \end{cases}
$$


对于微分方程组，我们传入`[y,u]`两个函数的原函数值，返回的函数值为`[y’,u’]`。所以，只需要对每个微分表达式给出解析形式就可以了。代码如下：

```python
# odeint是通过把二阶微分转化为一个方程组的形式求解高阶方程的
# y''=20(1-y^2)y'-y
def fvdp(y,t):
    '''
    要把y看出一个向量，y = [dy0,dy1,dy2,...]分别表示y的n阶导，那么
    y[0]就是需要求解的函数，y[1]表示一阶导，y[2]表示二阶导，以此类推
    '''
    dy1 = y[1]      # y[1]=dy/dt，一阶导                     y[0]表示原函数
    dy2 = 20*(1-y[0]**2) * y[1] - y[0]                    # y[1]表示一阶微分
    # y[0]是最初始，也就是需要求解的函数
    # 注意返回的顺序是[一阶导， 二阶导]，这就形成了一阶微分方程组
    return [dy1, dy2] 
    
# 求解的是一个二阶微分方程，所以输入的时候同时输入原函数y和微分y'
# y[0]表示原函数， y[1]表示一阶微分
# dy1表示一阶微分， dy2表示的是二阶微分
# 可以发现，dy1和y[1]表示的是同一个东西
# 把y''分离变量分离出来： dy2=20*(1-y[0]**2)*y[1]-y[0]
def solve_second_order_ode():
    '''
    求解二阶ODE
    '''
    x = np.arange(0,0.25,0.01)#给x规定范围
    y0 = [0.0, 2.0] # 初值条件
    # 初值[3.0, -5.0]表示y(0)=3,y'(0)=-5
    # 返回y，其中y[:,0]是y[0]的值，就是最终解，y[:,1]是y'(x)的值
    y = odeint(fvdp, y0, x)
    
    y1, = plt.plot(x,y[:,0],label='y')
    y1_1, = plt.plot(x,y[:,1],label='y‘')             
    plt.legend(handles=[y1,y1_1])   #创建图例
    
    plt.show()
solve_second_order_ode()
```

定义函数`fvdp`，传入`y`的原函数值和一阶导数值（列表传入），返回`y`的一阶导数值和二阶导数值。初值条件`y(0)=0`和`y'(0)=2`传入`odeint`函数中，自变量是取值`[0, 0.25)`的一个等距数组。解得的`y`其实包含两列，第一列是函数值，第二列是导数值。结果的图像如下。

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423224853.png)

图2.2.3 fvdp函数求解图

图2.1.5展示的是原函数$y(x)$与一阶导数$y'(x)$的图像。从图像中可以看到，原函数$y(x)$呈现出一种振荡衰减的趋势，随着$x$的增加，$y(x)$的振幅逐渐减小，最终趋于稳定。这是因为二阶微分方程中的非线性项起到了阻尼作用，当y的绝对值接近$1$时，该项的值变小，从而减弱了$y$的增长速率，导致振荡的衰减。

同时，一阶导数*y*′(*x*)的图像显示出与原函数相似的振荡衰减模式，但相比之下，其变化更加剧烈。这是因为直接受到非线性阻尼项的影响，而y*y*则是间接受到影响。

总的来说，这个微分方程组描述了一个非线性阻尼振荡系统，其解的行为随着初始条件和时间的变化而发生变化。在这个例子中，初始条件*y*(0)=0和*y*′(0)=2导致了一个振荡衰减的解，这种解在物理学和工程学中很常见，用于描述许多实际系统的动态行为。

我们再来看一个更高阶函数的求解的案例。

**例2.6** 使用scipy解下面这个高阶微分方程的数值解：
$$
y^{'''}+y^{''}-y^{'}+y=\cos t,\space\space\space\space y(0)=0,y^{'}=\pi ,y^{''}(0)=0
$$
这个案例当然可以和上面一样如法炮制，输入`[y, y', y'']`返回`[y', y'', y''']`。这里再次介绍一个案例是想引出Python求微分方程数值解的另一个函数`solve_ivp`的用法。

首先，仍然是通过换元法对函数进行定义：

```python
def f(y,t):
    dy1 = y[1]
    dy2 = y[2]
    dy3 = -y[0]+dy1-dy2-np.cos(t)
    return [dy1,dy2,dy3]
```

`Solve_ivp`函数的用法与`odeint`非常类似，只不过比`odeint`多了两个参数。一个是`t_span`参数，表示自变量的取值范围；另一个是`method`参数，可以选择多种不同的数值求解算法。常见的内置方法包括`RK45`, `RK23`, `DOP853`, `Radau`, `BDF`等多种方法，通常使用`RK45`多一些。它的使用方法与`odeint`对比起来很类似，对这个问题进行代码实现如下：

```python
import numpy as np
from scipy.integrate import odeint, solve_ivp
import matplotlib.pyplot as plt

pi = np.pi

# 用于 odeint 的函数
def f_odeint(y, t):
    dy1 = y[1]  # First derivative
    dy2 = y[2]  # Second derivative
    dy3 = -y[0] + y[1] - y[2] - np.cos(t)  # Third derivative
    return [dy1, dy2, dy3]

# 用于 solve_ivp 的函数
def f_solve_ivp(t, y):
    dy1 = y[1]  # First derivative
    dy2 = y[2]  # Second derivative
    dy3 = -y[0] + y[1] - y[2] - np.cos(t)  # Third derivative
    return [dy1, dy2, dy3]

def solve_high_order_ode():
    '''
    求解高阶ODE
    '''
    t = np.linspace(0, 6, 1000)
    tspan = (0.0, 6.0)
    y0 = [0.0, pi, 0.0]  # 初始条件: y(0)=0, y'(0)=π, y''(0)=0

    # 使用 odeint 求解
    y_odeint = odeint(f_odeint, y0, t)

    # 使用 solve_ivp 求解
    sol = solve_ivp(f_solve_ivp, t_span=tspan, y0=y0, t_eval=t)  # Ensure the correct function is used here

    plt.figure(figsize=(10, 8))

    plt.subplot(211)
    plt.plot(t, y_odeint[:, 0], label='y(0) Initial Function (odeint)')
    plt.plot(t, y_odeint[:, 1], label='y(1) First Derivative (odeint)')
    plt.plot(t, y_odeint[:, 2], label='y(2) Second Derivative (odeint)')
    plt.legend()
    plt.grid(True)

    plt.subplot(212)
    plt.plot(sol.t, sol.y[0], 'r--', label='y(0) Initial Function (solve_ivp)')
    plt.plot(sol.t, sol.y[1], 'g--', label='y(1) First Derivative (solve_ivp)')
    plt.plot(sol.t, sol.y[2], 'b-', label='y(2) Second Derivative (solve_ivp)')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()

solve_high_order_ode()
```

> solve_ivp 和 odeint 两个函数都可以解偏微分方程，但是solve_ivp可以不考虑参数顺序，odeint必须要考虑参数顺序（经验之谈）。

这里通过`matplotlib.pyplot`中提供的绘图接口绘制了两个数值解的图像。由于没有设置`method`参数，这里默认`solve_ivp`使用`RK45`（4-5阶 Runge-Kutta 法）方法进行求解。所解得的结果如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423225734.png)

图2.2.4 Runge-Kutta 法求解图

图中上半部分是使用`odeint`求解得到的结果，下半部分是由`solve_ivp`得到的结果，二者大差不差。一般来说对于普通的微分方程`odeint`与`solve_ivp`得到的结果差异不会太大，但有些情况下函数的微分容易发散，就会导致求解结果出现比较大的差异。`odeint`内置的原理也是4-5阶 Runge-Kutta 法，版本比较早所以求解也相对较为稳定。但`solve_ivp`则是后来新增的方法，有可能出现不太稳定的现象，内置方法较多所以也更加灵活。

Python求解微分方程组的模式有两种：一是采用基于基本原理自己写相关函数，这样操作比较繁琐，但是对于整个的求解过程会比较清晰明了；第二就是利用python下面的ode求解器，熟悉相关的输入输出，就可以完成数值求解。基于这个demo，在不同方向领域可以套用不同的微分方程组模型，进行仿真求解。但无论是常微分方程组还是偏微分方程组，使用的都是同一套思路，就是用差分代替微分。

**例2.7** 使用scipy解下面这个微分方程组的数值解：
$$
\begin{cases} x^{'}(t)=-x^3-y,(13) \\ y^{'}(t)=-y^3+x.(14) \end{cases}
$$
这个例子和例2.2很像，但不同的是这是也一个非线性方程组。那么，输入就需要以数组的形式传入`[x, y]`两个函数的函数值，返回它们的导数值。这里使用`solve_ivp`对这个方程组进行求解如下：

```python
def fun(t, w):
    x = w[0]
    y = w[1]
    return [-x**3-y,-y**3+x]
# 初始条件
y0 = [1,0.5]
yy = solve_ivp(fun, (0,100), y0, method='RK45',t_eval = np.arange(0,100,0.2) )
t = yy.t
data = yy.y
plt.plot(t, data[0, :])
plt.plot(t, data[1, :])
plt.xlabel("时间s")
plt.show()
```

绘制图像如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423230056.png)

图2.2.5 solve_ivp函数求解图

可以看到二者处于相互干扰的震荡状态，振幅随着时间的推移逐渐收敛并趋于稳定。 如果在微分方程组里面还出现了高阶微分，我们又应该怎么做呢？来看下面这个例子：

**例2.8** 使用 scipy 解下面这个微分方程组的数值解：
$$
\begin{cases} x^{''}(t)+y^{'}(t)+3x(t)=\cos (2t),\space\space (15)\\ y^{''}(t)-4x{'}(t)+3y(t)=\sin (2t), \space\space (16) \\ x^{'}(0)=\frac{1}{5}, y^{'}(0)=\frac{6}{5},x(0)=y(0)=0.\space\space (17) \end{cases}
$$
这个例子就比较有趣了，在方程组里面涉及到了两个函数的导数怎么求解呢？本质上还是要使用换元法。完全可以令*u*=*x*’, *v*=*y*’，然后带入到方程组中把一个二元二阶微分方程组变为四元一阶微分方程组。代码实现如下所示：

```python
def fun(t, w):
    x = w[0]
    y = w[1]
    dx = w[2]
    dy = w[3]
    # 求导以后[x,y,dx,dy]变为[dx,dy,d2x,d2y]
    # d2x为w[2]，d2y为w[5]
    return [dx,dy,-dy-3*x+np.cos(2*t),4*dx-3*y+np.sin(2*t)]
# 初始条件
y0 = [0,0,1/5,1/6]
yy = solve_ivp(fun, (0,100), y0, method='RK45',t_eval = np.arange(0,100,0.2) )
t = yy.t
data = yy.y
plt.figure(figsize=(12,6))
plt.subplot(1,2,1)
plt.plot(t, data[0, :])
plt.plot(t, data[1, :])
plt.legend(['x','y'])
plt.xlabel("时间s")
plt.subplot(1,2,2)
plt.plot(t, data[2, :])
plt.plot(t, data[3, :])
plt.legend(["x' ","y' "])
plt.xlabel("时间s")
plt.show()
```

得到的图像如图所示：

![600](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423230519.png)

图2.2.6 四元一阶方程求解图

可以看到，图像呈现出一定的周期规律但并不是简谐运动。这样的方程解往往在物理学中有着实际意义，例如，这样的方程可以描述物体同时出现平动和摆动的过程中，位移-速度-加速度与角度-角速度-角加速度之间存在的关系。这样的例子曾出现在2022年全国大学生数学建模竞赛A题中，我们后面可以看到。 最后一个例子是对蝴蝶效应的求解。

例2.9 使用scipy求解洛伦兹系统的数值解，参数与初始值自设：
$$
\begin{cases} \frac{dx}{dt}=p(y-x),(18)\\ \frac{dx}{dt}=x(r-z),(19)\\ \frac{dz}{dt}=xy-bz,(20) \end{cases}
$$
有前面的例子作为经验，我们知道x y z都是函数其余的都是参数。利用solve_ivp很容易求解这个系统的代码：

```python
import numpy as np
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
def dmove(Point, t, sets):
    p, r, b = sets
    x, y, z = Point
    return np.array([p*(y-x), x*(r-z), x*y-b*z])
t = np.arange(0, 30, 0.001)
P1 = odeint(dmove, (0., 1., 0.), t, args=([10., 28., 3.],))
P2 = odeint(dmove, (0., 1.01, 0.), t, args=([10., 28., 3.],)) 
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(P1[:,0], P1[:,1], P1[:,2])
ax.plot(P2[:,0], P2[:,1], P2[:,2])
plt.show()
```

`Mpl_toolkits.mplot3d`提供了进行三维曲线、曲面绘制的函数，这里使用里面提供的三维坐标系绘制洛伦兹系统中点的运动轨迹。我们这里基于不同的初值绘制了两个点的轨迹`P1`和`P2`，并展示在图中：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423231009.png)

图2.2.7 洛伦兹系统中点的运动轨迹图

可以看到，曲线的形状呈现双螺旋状，有些像蝴蝶的翅膀。所以洛伦兹系统又被叫做“蝴蝶效应”。蝴蝶效应本质上就是指，即使给这个系统的初始值一点微小的变化，曲线的形状也会出现很大不同。仅仅是把$y$改变了$0.01$，曲线的密集程度与蝴蝶翅膀的大小也是有所不同的。这是个混沌系统里面的典型案例。

### 2.3. 偏微分方程的数值求解

偏微分方程是针对多元函数来说的，它在物理学中有着很深刻的现实意义。但是，偏微分方程往往比常微分方程更难求解，并且Python也没有提供偏微分方程的专用工具包。怎么求解这些偏微分方程呢？我们要始终把握一个思想：就是把连续的问题离散化。这一节会通过一系列的物理案例来看到Python如何求解一些典型的偏微分方程。

#### 2.3.1. 偏微分方程数值解的理论基础

偏微分方程实际上就是由多元函数、自变量与多元函数的偏导数及高阶偏导数之间构成的方程。它在工程中很多地方都有深刻应用，比如波动力学、热学、电磁学等。我们常研究的就是二元函数的二阶偏微分方程，其基本形式为：
$$
A\frac{\delta^2 f}{\delta x^2} + 2B\frac{\delta^2 f}{\delta x\delta y} +C\frac{\delta^2 f}{\delta y^2}+D\frac{\delta f}{\delta x}+E\frac{\delta f}{\delta y}+Ff=0.
$$
在方程中，如果*A*、*B*、*C*三个常系数不全为0，定义判别式Δ=*B^2−4AC*，当判别式大于0称其为双曲线式方程；若判别式等于0，则称其为抛物线式方程；若判别式小于0，则称其为椭圆式方程。有关于这几类方程的基本性质与边界条件等内容请感兴趣的读者自行参考偏微分方程领域的书籍，我们的主要目光更多的聚焦在它的应用上。

刚刚我们说到，二阶偏微分方程主要有三类：椭圆方程，抛物方程和双曲方程。双曲方程描述变量以一定速度沿某个方向传播，常用于描述振动与波动问题。椭圆方程描述变量以一定深度沿所有方向传播，常用于描述静电场、引力场等稳态问题。抛物方程描述变量沿下游传播，常用于描述热传导和扩散等瞬态问题。它们都在工程中有实际应用。

偏微分方程的定解问题通常很难求出解析解，只能通过数值计算方法对偏微分方程的近似求解。常用偏微分方程数值解法有包括有限差分方法、有限元方法、有限体方法、共轭梯度法，等等。在使用这些数值方法时通常先对问题的求解区域进行网格剖分，然后将定解问题离散为代数方程组，求出在离散网格点上的近似值。

偏微分方程的典型应用有很多。描述热源传热过程中温度变化的热传导方程本质上是一个抛物类微分方程。大名鼎鼎的韦东奕大神所着重研究的纳维-斯托克斯方程，所描述的是流体流速与流体密度、压力、外阻力之间的关系，在机械工程、能源工程等制造领域有着重要应用。还有电磁场中非常重要的麦克斯韦方程组，本质上也是偏微分方程。下面我们会根据一系列的具体应用来看如何去构建与求解微分方程。

#### 2.3.2 偏微分方程数值解的应用案例

解偏微分方程由于缺少特定的工具包，更多的情况下需要自己写代码求解。这就迫使我们不得不理解微分方程求解的核心思想：以离散代替连续，用差分逼近微分。 一类有限差分法求解偏微分方程数值解的步骤包括如下几步：

1. 定义初始条件函数 *U*(*x*,0)；
2. 输入模型参数，对于待求解函数*F*(*x*,*t*)定义求解的时间域(tStart,tEnd)和空间域(xMin,xMax)，设置差分步长d*t*, nNodes；
3. 初始化解空间；
4. 根据递推规则递推求解差分方程在区间`[xa, xb]`的数值解，获得网格节点的处的函数值，最终填满整个解空间。

我们首先用一个常微分方程的应用揭示这一过程。

**例2.10** 使用偏微分方程对RC电路进行建模，分析电容放电过程中电量随时间的变化。 ![400](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423231638.png)

图2.3.1 洛伦兹系统中点的运动轨迹图

式子中*I*代表了电流，*R*代表电阻值，*Q*代表电容电量，*C*代表电容值。为什么这个电路叫*RC*电路？这不仅仅是由于电路中包括电阻和电容两个核心元件，也是指*τ*=*RC*的乘积是一个重要的参数。令，这个常微分方程存在很明显的解析解：
$$
Q(t)=Q_0e^{-t/r}
$$
那么我们为什么还要来谈这个案例？我想通过这个案例来给大家讲述一下把一个连续问题离散化的方法。我们先从一阶微分方程的计算原理说起。将一阶微分方程离散化，实际上也就是把它写成迭代、差分的形式。对于一个连续的问题有
$$
\begin{cases} \frac{dy}{dt}=f(y,t),(21)\\ y_0(t_0)=y_0.(22)\\ \end{cases}
$$
画出y(t)*y*(*t*)的图像如图所示：

![img](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423232711.png)

图2.3.2 y(t)图象

在图中，如果求解区间为$[x_0, x_0+h]$，已知点$(x_{0},f(x_{0}))$，要求解$f(x_0+h)$应该怎么做？根据微分方程$f(x,y)=0$可以很容易地解得每个点的导数值。在距离$h$很小的情况下，我们说，切线与割线是可以逼近的，也就可以用切线的对应值逼近函数值。但在上图中，我们发现：如果使用$x_0$点处的导数作为切线斜率，那么得到的估计值是比实际值要小的；但如果使用$x_0+h$点的导数作为斜率，那么估计值比实际值又大一些。能不能取一个折中的方案呢？很简单，把二者进行一个平均就可以了： $$ y_{n+1} = y_{n} + \frac{f(y_{n}, t_{n}) + f(y_{n+1}, t_{n+1})}{2} h. \tag{2.3.5} $$ 那么对于例2.10中的电容放电过程，这个问题的代码可以这样写：

```python
import numpy as np
import matplotlib.pyplot as plt
rc = 2.0 #设置常数
dt = 0.5 #设置步长
n = 1000 #设置分割段数
t = 0.0 #设置初始时间
q = 1.0 #设置初始电量
#先定义三个空列表
qt=[] #用来盛放差分得到的q值
qt0=[] #用来盛放解析得到的q值
time = [] #用来盛放时间值
for i in range(n):
    t = t + dt
    q1 = q - q*dt/rc #qn+1的近似值
    q = q - 0.5*(q1*dt/rc + q*dt/rc) #差分递推关系
    q0 = np.exp(-t/rc) #解析关系
    qt.append(q) #差分得到的q值列表
    qt0.append(q0) #解析得到的q值列表
    time.append(t) #时间列表
plt.plot(time,qt,'o',label='Euler-Modify') #差分得到的电量随时间的变化
plt.plot(time,qt0,'r-',label='Analytical') #解析得到的电量随时间的变化
plt.xlabel('time')
plt.ylabel('charge')
plt.xlim(0,20)
plt.ylim(-0.2,1.0)
plt.legend(loc='upper right')
plt.show()
```

这个案例我们没有用任何包里面的微分方程求解器，纯手写的情况下解了这个微分方程。它的结果如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423233132.png)

图2.3.3 电容放电曲线

这个方法被称为**Euler 法**，是在求解常微分方程中的一种常见数值方法。

**例2.11** 一维热传导方程是一个典型的抛物型二阶偏微分方程。设u(x,t)*u*(*x*,*t*)表示在时间t*t*,空间x*x*处的温度，则根据傅里叶定律(单位时间内流经单位面积的热量和该处温度的负梯度成正比),可以导出热传导方程：
$$
\frac{\delta u}{\delta t} = \lambda \frac{\delta^2u}{\delta x^2}
$$
其中*λ*称为热扩散率，*k*,*C*,*p*分别为热导率，比热和质量密度，是由系统本身确定的常量。问题的形式为：
$$
\frac{\delta u(x,t)}{\delta t} = \lambda \frac{\delta^2u(x,t)}{\delta x^2}\\
0 \le t \le 1000,0 \le x \le 3\\
u(x,0)=4x(3-x)\\
u(0, t)=u(3,t)=0
$$
请求解这个问题的数值解。

一元函数的微分方程可以绘制曲线，那么二元函数的偏微分方程应该就可以绘制曲面。那么，怎么对这个问题进行离散化呢？对于一个一般的二阶抛物型偏微分方程：
$$
\frac{\delta u(x,t)}{\delta t} = \lambda \frac{\delta^2u(x,t)}{\delta x^2}\\
0\le t\le T,0\le x \le l\\
u(x,0)=f(x)\\
u(0, t)=g_1(t)\\
u(3,t)=g_2(t)
$$
对时间和空间的一阶偏导数微分是容易离散化的：
$$
\frac{\delta u(x_i, t_k)}{\delta t_k} \longrightarrow \frac{u(x_i,t_{k + 1}) - u(x_i, t_k)}{\Delta t},\\
\frac{\delta u(x_i, t_k)}{\delta x_i} \longrightarrow \frac{u(x_{i + 1},t_k) - u(x_i, t_k)}{\Delta x}.
$$
那么，对于空间的二阶微分，可以看作是一阶微分的再微分：
$$
\frac{\delta^2 u(x_i, t_k)}{\delta x_i^2} \longrightarrow \frac{\frac{u(x_{i + 1}, t_k) - u(x_i, t_k)}{\Delta x} - \frac{u(x_i, t_k)-u(x_{i - 1},t_k)}{\Delta x}}{\Delta x}
$$
也就是
$$
\frac{u(x_{i  +1}, t_k) + u(x_{i - 1}, t_k)-2u(x_i,t_k)}{(\Delta x)^2}
$$
了解了这个原理，我们将例2.11中的边界条件和迭代规则进行翻译如下：

```python
import numpy as np
import matplotlib.pyplot as plt

h = 0.1#空间步长
N =30#空间步数
dt = 0.0001#时间步长
M = 10000#时间的步数
A = dt/(h**2) #lambda*tau/h^2
U = np.zeros([N+1,M+1])#建立二维空数组
Space = np.arange(0,(N+1)*h,h)#建立空间等差数列，从0到3，公差是h
#边界条件
for k in np.arange(0,M+1):
    U[0,k] = 0.0
    U[N,k] = 0.0
#初始条件
for i in np.arange(0,N):
    U[i,0]=4*i*h*(3-i*h)
#递推关系
for k in np.arange(0,M):
    for i in np.arange(1,N):
        U[i,k+1]=A*U[i+1,k]+(1-2*A)*U[i,k]+A*U[i-1,k]
```

将解空间抽象为以时间为横坐标、空间为纵坐标的网格，翻译时间与空间的边界条件，对于网格内每个点使用二重循环遍历每个点，根据差分后的迭代方程进行演化。不同时刻的温度随空间坐标的变化图像如下：

```python
plt.plot(Space,U[:,0], 'g-', label='t=0',linewidth=1.0)
plt.plot(Space,U[:,3000], 'b-', label='t=3/10',linewidth=1.0)
plt.plot(Space,U[:,6000], 'k-', label='t=6/10',linewidth=1.0)
plt.plot(Space,U[:,9000], 'r-', label='t=9/10',linewidth=1.0)
plt.plot(Space,U[:,10000], 'y-', label='t=1',linewidth=1.0)
plt.ylabel('u(x,t)', fontsize=20)
plt.xlabel('x', fontsize=20)
plt.xlim(0,3)
plt.ylim(-2,10)
plt.legend(loc='upper right')
plt.show()
```

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423234214.png)

在图中可以看到，随着时间的推进，温度分布呈现出一种动态变化的过程。在$t = 0$时（绿线），我们看到起始的温度分布情况；随着时间的推移，图中的曲线显示出温度在不同位置的变化。

- 在 *t*=3/10（蓝线）时，曲线稍微上升，表明温度在增加。
- 到了 *t*=6.10（黑线），温度继续上升，但上升的速度似乎开始减缓。
- *t*=9/10（红线）时，曲线达到高点之后开始回落，这可能意味着一个冷却过程的开始。
- 到*t*=1（黄线）时，温度分布与时相比t=0*t*=0明显增高，但比*t*=9/10时有所降低，显示了经过一段时间后温度分布的稳定状态。

整体上，这些曲线描述了温度如何随着时间从初始状态演变到一个稳态分布。这种分析对于理解热传导、扩散过程，以及如何在时间上控制温度分布都是非常有用的。图形的yy轴显示的是*u*(*x*,*t*)，即位置*x*在时间t*t*的温度，而x轴表示空间坐标。曲线下方较深的颜色表示较低的温度值，而曲线顶部较浅的颜色表示较高的温度值。通过设置坐标轴的范围和图例的位置，这张图为观察者提供了清晰的数据解读。

图中的yy轴标记为 ，表示在位置x和时间t的温度，x轴标记为*x*表示空间坐标。可视窗口的设置为*x*值从0到3，*u*(*x*,*t*)的值从−2到10。

将整个网格空间的温度分布热力图绘制如图所示：

```python
#温度等高线随时空坐标的变化，温度越高，颜色越偏红
extent = [0,1,0,3] #时间和空间的取值范围
levels = np.arange(0,10,0.1)#温度等高线的变化范围0-10，变化间隔为0.1
plt.contourf(U,levels,origin='lower',extent=extent,cmap=plt.cm.jet)
plt.ylabel('x', fontsize=20)
plt.xlabel('t', fontsize=20)
plt.show()
```

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423234553.png)

从图中可以看到的是一个温度分布的热力图，其中颜色的变化表明了不同温度的区域。温度越高，颜色越偏向红色，温度较低的区域则显现为蓝色。这种热力图通常用于显示温度如何在空间内分布以及如何随时间变化。 图中的$\mathrm{y}$轴（标记为$x$）代表空间坐标，而$\mathrm{x}$轴（标记为$t$）代表时间。热力图覆盖的范围是时间从 $0$ 到 $1$，空间从 $0$ 到 $3$。可以清晰地看到，在图的左侧（时间较早）温度整体较低，而在图的右侧（时间较晚）温度较高，这表示随着时间的推移，整体温度有所上升。

等温线的密集区表示温度变化较大的区域，而等温线的稀疏区则表示温度变化较小的区域。从热力图中我们可以推断，最高温区域集中在图的右上角，而最低温区域则在左下角。通过色彩的深浅变化，我们可以直观地看到温度在空间中如何变化以及时间对这种分布的影响。

**例2.12** 平流过程是大气运动中重要的过程。平流方程（Advection equation）描述某一物理量的平流作用而引起局地变化的物理过程，最简单的形式是一维平流方程。
$$
\frac{\delta u}{\delta t} + v\frac{\delta u}{\delta x} = 0,\\
u(x,0)=F(x).
$$
式中*u*为某物理量，*v*为系统速度，*x*为水平方向分量，*t*为时间。该方程可以求得解析解：
$$
u(x,t)=F(x-vt).
$$
考虑一维线性平流偏微分方程的数值解法，采用有限差分法求解。简单地， 采用一阶迎风格式的差分方法（First-order Upwind)，一阶导数的差分表达式为：
$$
\frac{\delta u}{\delta x} |_{i,j} \longrightarrow \frac{u_{i + 1, j} - u_{i, j}}{\Delta x},\\
u_{i, j+1} = u_{i, j} - v\frac{\Delta t}{\Delta x}(u_{i,j} - u_{i - 1,j}).
$$
代码实现如下：

```python
# eg.3. 
import numpy as np
import matplotlib.pyplot as plt
# 初始条件函数 U(x,0)
def funcUx_0(x, p): 
    u0 = np.sin(2 * (x-p)**2)
    return u0
# 输入参数
v1 = 1.0  # 平流方程参数，系统速度
p = 0.25  # 初始条件函数 u(x,0) 中的参数
tc = 0  # 开始时间
te = 1.0  # 终止时间: (0, te)
xa = 0.0  # 空间范围: (xa, xb)
xb = np.pi
dt = 0.02  # 时间差分步长
nNodes = 100  # 空间网格数
# 初始化
nsteps = round(te/dt)
dx = (xb - xa) / nNodes
x = np.arange(xa-dx, xb+2*dx, dx)
ux_0 = funcUx_0(x, p)
u = ux_0.copy()  # u(j)
ujp = ux_0.copy()  # u(j+1)
# 时域差分
for i in range(nsteps):
    plt.clf()  # 清除当前 figure 的所有axes, 但是保留当前窗口
    # 计算 u(j+1)
    for j in range(nNodes + 2):
        ujp[j] = u[j] - (v1 * dt/dx) * (u[j] - u[j-1])
    # 更新边界条件
    u = ujp.copy()
    u[0] = u[nNodes + 1]
    u[nNodes+2] = u[1]
    tc += dt
    # 绘图
plt.plot(x, u, 'b-', label="v1= 1.0")
plt.axis((xa-0.1, xb + 0.1, -1.1, 1.1))
plt.xlabel("x")
plt.ylabel("U(x)")
plt.legend(loc=(0.05,0.05))
plt.show()
```

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423235312.png)

图2.3.6 平流大气运动图

从图中可以发现，函数$U(x)$显示了随空间$x$变化的波动性质。这个波动可能代表一维平流方程在某一特定时间$t$的数值解。图中蓝色的线表示速度$v_{1} = 1.0$下的解，而波形的变化暗示了初态条件$U(x,0) = \sin \big[ 2(x-p)^{2} \big]$随时间的演化。

注意到曲线在x轴的不同位置出现了波峰和波谷，这表明了函数值随位置的变化并非均匀。由于是一阶迎风格式的数值解法，我们可能会观察到与理论解相比有一定程度的数值扩散或者数值耗散，这是由于一阶方法在数值传输过程中的固有特性。

在这个示例中，曲线的形状可能表示了经过一段时间演化后，平流作用在初始条件*U*(*x*,0)上的效果。如果初始波形移动的速度是*v*1，那么这个图形可能表明波形随着时间的推进而向右移动。然而，由于是一阶迎风差分，我们也可以预期波形会有一定程度的变形，这在实际中表现为波峰变得不那么尖锐，以及波形整体变得更加平坦。这是数值方法的离散化误差导致的结果。

这个数值解可以帮助理解平流方程在数值模拟中的行为，特别是当理论解难以获得时，数值方法提供了一种有效的途径来近似解决实际问题。

**例2.13** 波动方程（wave equation）是典型的双曲偏微分方程，广泛应用于声学，电磁学，和流体力学等领域，描述自然界中的各种的波动现象，包括横波和纵波，例如声波、光波和水波。考虑如下二维波动方程的初边值问题：

![](G:\code\Intro-mathmodel\笔记\屏幕截图 2024-09-02 211400.png)它的代码实现如下：

```python
import numpy as np
import matplotlib.pyplot as plt
# 模型参数
c = 1.0  # 波的传播速率
tc, te = 0.0, 1.0  # 时间范围，0<t<te
xa, xb = 0.0, 1.0  # 空间范围，xa<x<xb
ya, yb = 0.0, 1.0  # 空间范围，ya<y<yb
# 初始化
c2 = c*c  # 方程参数
dt = 0.01  # 时间步长
dx = dy = 0.02  # 空间步长
tNodes = round(te/dt)  # t轴 时序网格数
xNodes = round((xb-xa)/dx)  # $\mathrm{x}$轴 空间网格数
yNodes = round((yb-ya)/dy)  # $\mathrm{y}$轴 空间网格数
tZone = np.arange(0, (tNodes+1)*dt, dt)  # 建立空间网格
xZone = np.arange(0, (xNodes+1)*dx, dx)  # 建立空间网格
yZone = np.arange(0, (yNodes+1)*dy, dy)  # 建立空间网格
xx, yy = np.meshgrid(xZone, yZone)  # 生成网格点的坐标 xx,yy (二维数组)
# 步长比检验(r>1 则算法不稳定)
r = 4 * c2 * dt*dt / (dx*dx+dy*dy)
print("dt = {:.2f}, dx = {:.2f}, dy = {:.2f}, r = {:.2f}".format(dt,dx,dy,r))
assert r < 1.0, "Error: r>1, unstable step ratio of dt2/(dx2+dy2) ."
rx = c*c * dt**2/dx**2
ry = c*c * dt**2/dy**2
# 绘图
fig = plt.figure(figsize=(8,6))
ax1 = fig.add_subplot(111, projection='3d')
# 计算初始值
U = np.zeros([tNodes+1, xNodes+1, yNodes+1])  # 建立三维数组
U[0] = np.sin(6*np.pi*xx)+np.cos(4*np.pi*yy)  # U[0,:,:]
U[1] = np.sin(6*np.pi*xx)+np.cos(4*np.pi*yy)  # U[1,:,:]
surf = ax1.plot_surface(xx, yy, U[0,:,:], rstride=2, cstride=2, cmap=plt.cm.coolwarm)
# 有限差分法求解
for k in range(2,tNodes+1):
    for i in range(1,xNodes):
        for j in range(1,yNodes):
            U[k,i,j] = rx*(U[k-1,i-1,j]+U[k-1,i+1,j]) + ry*(U[k-1,i,j-1]+U[k-1,i,j+1])\
                     + 2*(1-rx-ry)*U[k-1,i,j] -U[k-2,i,j]
surf = ax1.plot_surface(xx, yy, U[k,:,:], rstride=2, cstride=2, cmap='rainbow')
ax1.set_xlim3d(0, 1.0)
ax1.set_ylim3d(0, 1.0)
ax1.set_zlim3d(-2, 2)
ax1.set_title("2D wave equationt (t= %.2f)" % (k*dt))
ax1.set_xlabel("x")
ax1.set_ylabel("y")
plt.show()
```

这个函数是一个三元函数，实际上是可以做出一个曲面随时间变化的动画的。大家可以尝试使用matplotlib提供的动画功能进行绘制，这里展示其中一个瞬时状态：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240424000918.png)

图2.3.7 波形方程求解图

**例2.14** 热传导方程（heat equation）是典型的抛物形偏微分方程，也成为扩散方程。广泛应用于声学，电磁学，和流体力学等领域，描述自然界中的各种的波动现象，包括横波和纵波，例如声波、光波和水波。之前的例2.11我们已经看到了一维热传导方程的求解，现在考虑如下二维热传导方程的初边值问题： 
$$
\begin{align} \frac{ \partial u }{ \partial t } &= \lambda \left( \frac{ \partial^{2} u }{ \partial x^{2} + \frac{ \partial^{2} u }{ \partial y^{2} } } \right) + q_{v}\\[0.5em] \frac{ \partial u(0, x, y) }{ \partial t } &= 0\\[0.5em] u(x,y,0) &= u_{0}(x,y),\\[0.5em] u(0,y,t) &= u_{a}(t), \quad u(1,y,t) = u_{b}(t),\\[0.5em] u(x,0,t) &= u_{c}(t), \quad u(x,1,t) = u_{d}(t).\\[0.5em] \end{align} \tag{2.3.17}
$$
  类似的，同上一个例子中的有限差分法，我们将这个方程离散化可以得到： 
$$
\begin{align} r_{x} &= \lambda^{2} \frac{(\Delta t)^{2}}{(\Delta x)^{2}}, \\[0.5em] r_{y} &= \lambda^{2} \frac{(\Delta t)^{2}}{(\Delta y)^{2}}, \\[0.5em] u_{i,j,k+1} &= r_{x}\big( u_{i-1,j,k} + u_{i+1,j,k} \big) \\ &+ 2\big( 1 - r_{x} - r_{y} \big) u_{i,j,k} + r_{y} \big( u_{i,j-1,k} + u_{i,j+1,k} \big) - u_{i,j,k-1}. \end{align} \tag{2.3.18}
$$
  事实上，这个方程还有一种矩阵形式： 
$$
U_{k+1} = U_{k} + r_{x}AU_{k} + r_{y}BU_{k} + q_{v}\Delta t, \tag{2.3.19}
$$
  其中 
$$
 A = \left[ \begin{matrix} -2 & -1 & 0 & \cdots & 0 & 0\\ 1 & -2 & 1 & \cdots & 0 & 0\\ 0 & 1 & -2 & \cdots & 0 & 0\\ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\ 0 & 0 & 0 & \cdots & 1 & -2 \end{matrix} \right]_{N_{x} \times N_{x}}, \quad B = \left[ \begin{matrix} -2 & -1 & 0 & \cdots & 0 & 0\\ 1 & -2 & 1 & \cdots & 0 & 0\\ 0 & 1 & -2 & \cdots & 0 & 0\\ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\ 0 & 0 & 0 & \cdots & 1 & -2 \end{matrix} \right]_{N_{y} \times N_{y}}. \tag{2.3.20} 
$$
 我们这次就用这个矩阵形式去进行偏微分方程的求解：

```python
import numpy as np
import matplotlib.pyplot as plt
def showcontourf(zMat, xyRange, tNow):  # 绘制等温云图
    x = np.linspace(xyRange[0], xyRange[1], zMat.shape[1])
    y = np.linspace(xyRange[2], xyRange[3], zMat.shape[0])
    xx,yy = np.meshgrid(x,y)
    zMax = np.max(zMat)
    yMax, xMax = np.where(zMat==zMax)[0][0], np.where(zMat==zMax)[1][0]
    levels = np.arange(0,100,1)
    showText = "time = {:.1f} s\nhotpoint = {:.1f} C".format(tNow, zMax)
    plt.plot(x[xMax],y[yMax],'ro')  # 绘制最高温度点
    plt.contourf(xx, yy, zMat, 100, cmap=plt.cm.get_cmap('jet'), origin='lower', levels = levels)
    plt.annotate(showText, xy=(x[xMax],y[yMax]), xytext=(x[xMax],y[yMax]),fontsize=10)
    plt.colorbar()
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Temperature distribution of the plate')
    plt.show()
# 模型参数
uIni = 25  # 初始温度值
uBound = 25.0  # 边界条件
c = 1.0  # 热传导参数
qv = 50.0  # 热源功率
x_0, y0 = 0.0, 3.0  # 热源初始位置
vx, vy = 2.0, 1.0  # 热源移动速度
# 求解范围
tc, te = 0.0, 5.0  # 时间范围，0<t<te
xa, xb = 0.0, 16.0  # 空间范围，xa<x<xb
ya, yb = 0.0, 12.0  # 空间范围，ya<y<yb
# 初始化
dt = 0.002  # 时间步长
dx = dy = 0.1  # 空间步长
tNodes = round(te/dt)  # t轴 时序网格数
xNodes = round((xb-xa)/dx)  # $\mathrm{x}$轴 空间网格数
yNodes = round((yb-ya)/dy)  # $\mathrm{y}$轴 空间网格数
xyRange = np.array([xa, xb, ya, yb])
xZone = np.linspace(xa, xb, xNodes+1)  # 建立空间网格
yZone = np.linspace(ya, yb, yNodes+1)  # 建立空间网格
xx,yy = np.meshgrid(xZone, yZone)  # 生成网格点的坐标 xx,yy (二维数组)
# 计算 差分系数矩阵 A、B (三对角对称矩阵)，差分系数 rx,ry,ft
A = (-2) * np.eye(xNodes+1, k=0) + (1) * np.eye(xNodes+1, k=-1) + (1) * np.eye(xNodes+1, k=1)
B = (-2) * np.eye(yNodes+1, k=0) + (1) * np.eye(yNodes+1, k=-1) + (1) * np.eye(yNodes+1, k=1)
rx, ry, ft = c*dt/(dx*dx), c*dt/(dy*dy), qv*dt
# 计算 初始值
U = uIni * np.ones((yNodes+1, xNodes+1))  # 初始温度 u0
# 前向Euler 法一阶差分求解
for k in range(tNodes+1):
    t = k * dt  # 当前时间
    # 热源条件
    # (1) 恒定热源：Qv(x_0,y0,t) = qv, 功率、位置 恒定
    # Qv = qv
    # (2) 热源功率随时间变化 Qv(x_0,y0,t)=f(t)
    # Qv = qv*np.sin(t*np.pi) if t<2.0 else qv
    # (3) 热源位置随时间变化 Qv(x,y,t)=f(x(t),y(t))
    xt, yt = x_0+vx*t, y0+vy*t  # 热源位置变化
    Qv = qv * np.exp(-((xx-xt)**2+(yy-yt)**2))  # 热源方程
    # 边界条件
    U[:,0] = U[:,-1] = uBound
    U[0,:] = U[-1,:] = uBound
    # 差分求解
    U = U + rx * np.dot(U,A) + ry * np.dot(B,U) + Qv*dt
    if k % 100 == 0:
        print('t={:.2f}s\tTmax={:.1f}  Tmin={:.1f}'.format(t, np.max(U), np.min(U)))
showcontourf(U, xyRange, k*dt)  # 绘制等温云图
```

这段代码只需要把`showcontourf`放在循环体内即可实现动画效果，可以清晰看到热源在空间中的分布。我这里展示最后状态下的温度分布图：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240424222139.png)

图2.3.8 温度空间分布图

最终状态下的温度分布图显示了热源随时间在平板中移动的情况，并将热量传递给周围材料。图像中的红点标记了最高温度点，即‘热点’，对应于最后时间步骤中热源的当前位置。颜色渐变代表温度分布，红色是最热的区域，蓝色是最冷的。等温线表示温度相等的水平线。

热点周围的温度梯度平滑，这表明热量通过平板均匀扩散。这样的模拟在许多应用中都很有用，例如在散热器设计、理解制造过程中的热梯度，甚至在诸如地热源传播热量的自然现象中。

**例2.15** 椭圆偏微分方程是一类重要的偏微分方程，主要用来描述物理的平衡稳定状态，如定常状态下的电磁场、引力场和反应扩散现象等，广泛应用于流体力学、弹性力学、电磁学、几何学和变分法中。 考虑如下二维 Poisson 方程：

![](G:\code\Intro-mathmodel\笔记\屏幕截图 2024-09-02 211736.png)

这个方程怎么解呢？考虑二维椭圆偏微分方程的数值解法，采用有限差分法求解。简单地，采用五点差分格式表示二阶导数的差分表达式，将上述的偏微分方程离散为差分方程：

![](G:\code\Intro-mathmodel\笔记\屏幕截图 2024-09-02 211820.png)

椭圆型偏微分描述不随时间变化的均衡状态，没有初始条件，因此不能沿时间步长递推求解。对上式的差分方程，可以通过矩阵求逆方法求解，但当h*h*较小时网格很多，矩阵求逆的内存占用和计算量极大。于是，可以使用迭代松弛法递推求得二维椭圆方程的数值解。假定x*x*和y*y*的间距都为h*h*，松弛系数为w*w*，则迭代过程可以表示为：

![](G:\code\Intro-mathmodel\笔记\屏幕截图 2024-09-02 211840.png)

考虑一个特殊情况，也就是当*f*(*x*,*y*)=0的情况下，迭代松弛法的代码如下：

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
# 求解范围
xa, xb = 0.0, 1.0  # 空间范围，xa<x<xb
ya, yb = 0.0, 1.0  # 空间范围，ya<y<yb
# 初始化
h = 0.01  # 空间步长, dx = dy = 0.01
w = 0.5  # 松弛因子
nodes = round((xb-xa)/h)  # $\mathrm{x}$轴 空间网格数
# 边值条件
u = np.zeros((nodes+1, nodes+1))
for i in range(nodes+1):
    u[i, 0] = 1.0 + np.sin(0.5*(i-50)/np.pi)
    u[i, -1] = -1.0 + 0.5*np.sin((i-50)/np.pi)
    u[0, i] = -1.0 + 0.5*np.sin((i-50)/np.pi)
    u[-1, i] = 1.0 + np.sin(0.5*(50-i)/np.pi)
# 迭代松弛法求解
for iter in range(100):
    for i in range(1, nodes):
        for j in range(1, nodes):
            u[i, j] = w/4 * (u[i-1, j] + u[i+1, j] + u[i, j-1] + u[i, j+1]) + (1-w) * u[i, j]
# 绘图
x = np.linspace(0, 1, nodes+1)
y = np.linspace(0, 1, nodes+1)
xx, yy = np.meshgrid(x, y)
fig = plt.figure(figsize=(8,6))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(xx, yy, u, cmap=plt.get_cmap('rainbow'))
fig.colorbar(surf, shrink=0.5)
ax.set_xlim3d(0, 1.0)
ax.set_ylim3d(0, 1.0)
ax.set_zlim3d(-2, 2.5)
ax.set_title("2D elliptic partial differential equation")
ax.set_xlabel("X")
ax.set_ylabel("Y")
plt.show()
```

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240424222706.png)

从图中可以看到，解呈现出一系列波峰和波谷，这与边界条件的正弦函数有关。每个波峰和波谷都是颜色映射中的热点和冷点，分别代表着方程解的局部最大值和最小值。波峰出现在和轴的中间位置，而波谷则出现在四个角和边缘。颜色的变化代表了解的幅度，从红色的高值到蓝色的低值。整体上，解的形状表现出了椭圆方程特有的对称性和周期性。

sympy中的`pdsolve`给出了一些简单偏微分方程的解析解法，但sympy目前不支持二阶偏微分方程的求解。`pdsolve`的调用格式形如`pdsolve(eq, func=None, hint='default', dict=False, solvefun=None, **kwargs)`，具体使用我们可以看到下面的例子：

**例2.16** 使用sympy中的`pdsolve`解下面这个偏微分方程：
$$
-2\frac {\delta f}{\delta x} + 4\frac{\delta f}{\delta y} + 5f = e^{x + 3y} 
$$
可以给出如下代码：

```python
from sympy.solvers.pde import pdsolve
from sympy import Function, pprint, exp
from sympy.abc import x,y
f = Function('f')
eq = -2*f(x,y).diff(x) + 4*f(x,y).diff(y) + 5*f(x,y) - exp(x + 3*y)
pdsolve(eq)
```

给出的结果为：

```python
Eq(f(x, y), (F(4*x + 2*y)*exp(x/2) + exp(x + 4*y)/15)*exp(-y))
```

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240424222941.png)

图2.3.10 pdsolve求解方程图

\## 2.4 微分方程的应用案例

在本节中，我们将探讨微分方程在现实世界中的应用，特别是在工业和日常生活中的一些实例。通过这些案例，我们可以加深对微分方程建模过程的理解。
