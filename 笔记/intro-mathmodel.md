# intro-mathmodel

## 1. 解析方法与几何模型

### 1.1. 向量表示法与几何建模基本案例

#### 1.1.1. 几何建模的思想

分析几何问题，在现在这个阶段我们所掌握的方法大体上可以分为三种：

- **传统几何的演绎-证明体系**：这种体系下的方法都是基于已经被证明了的公理与定理体系（例如勾股定理、正弦定理、圆幂定理等），在解决问题的过程中更强调分析而非计算，往往是通过构造辅助线、辅助平面等利用严密的逻辑推理步步为营推导出最后的结果。这种方法往往分析起来会更加困难，但减少了计算量。
- **基于向量的计算化几何**：向量被引入几何当中最初的目的是为了表示有向线段，但后来大家发现基于向量的一些运算特性可以把一些数量问题统一化。几何图形中的边长、角度、面积可以转化为向量的模长、内积等求解，平行、垂直等可以转化为向量共线、内积为0等求解，就可以把所有几何问题都变成可计算的问题。这样的方法更加重视计算，并且除了传统的几何向量外，还可以构造直角坐标系从而获得坐标向量，运算更加方便。
- **基于极坐标与方程的解析几何**：这种方法其实可以回溯到当初学圆锥曲线的时期，把几何图形的相交、相切、相离抽象成方程解的问题。后来又学习过极坐标和参数方程，就会发现利用极坐标和参数方程去表示曲线实在是太方便了。这样的方法就可以把几何问题转化成一个代数问题来求解，大大提高了求解的效率。

##### 一些常见的公式与定理

- **三角形中的角度关系**：这是几何学中的基本概念之一，涉及到三角形内角和定理（三角形的三个内角之和等于180∘180∘）、直角三角形的角度关系（一个角为90∘90∘，另外两个角之和为90∘90∘）等。

- **勾股定理**：这是直角三角形中最著名的定理之一，表明直角三角形的两条直角边的平方和等于斜边的平方。即如果直角三角形的直角边长分别为*a*和*b*，斜边长为*c*，则有 
  $$
  a^2 + b^2=c^2
  $$

- **正弦定理**：这是解决三角形问题时非常有用的定理，它表明在任意三角形中，各边的长度与其对应角的正弦值之比相等。即如果三角形的边长分别为*a*、*b*、*c*，对应的角分别为*A*、*B*、*C*，则有 
  $$
  \frac{a}{\sin A} = \frac{b}{\sin B} = \frac{c}{\sin C}
  $$
  ，其中*R*是三角形外接圆的半径。

- **余弦定理**：在任意三角形中，任意一边的平方等于其他两边的平方和减去两倍的其他两边长度乘以它们夹角的余弦值。即如果三角形的边长分别为*a*、*b*、*c*，对应的角分别为*A*、*B*、*C*，则有 
  $$
  c^2=a^2+b^2-2abcosC
  $$
  。余弦定理在解决非直角三角形的问题中非常有用，尤其是在涉及边长和角度关系的问题中。

- **圆幂定理**：对于任意一点到圆的两条切线，它们的长度是相等的。对于任意一条经过该点的割线，割线的两段长度的乘积是一个常数，这个常数等于该点到圆心的距离的平方减去圆的半径的平方。圆幂定理在解决与圆有关的几何问题中非常有用。

- **切割线定理**（也称为割线-切线定理）：如果一条直线从外部点P切割圆，形成一条切线段*PT*和一条割线段*P**A**B*（A和B是割线与圆的交点），那么
  $$
  PT^2=PA*PB
  $$
  。这个定理在解决圆和直线关系的几何问题中很有帮助。

- **四点共圆**：四点共圆是一个判断四个点是否能在同一个圆上的几何概念。如果四个点*A*、*B*、*C*、*D*满足某种特定的关系，那么它们可以位于同一个圆上。这个概念在解决几何问题时非常重要，尤其是在证明四个点共圆的时候。常用的判断四点共圆的方法包括使用圆的方程、利用角的性质（如对顶角、圆周角等）等。

- **圆锥曲线的几何性质**：圆锥曲线（包括椭圆、双曲线和抛物线）拥有许多独特的几何性质。例如，椭圆的每一点到两个焦点的距离之和是一个常数；双曲线的每一点到两个焦点的距离之差的绝对值是一个常数；抛物线上的每一点到焦点的距离等于该点到准线的距离。

- **圆锥曲线的光学性质**：圆锥曲线的光学性质是指光线在圆锥曲线上的反射和折射特性。例如，椭圆上的任意一点反射到两个焦点的光线路径长度相等；抛物线上的任意一点反射到焦点的光线都平行于对称轴；双曲线上的任意一点反射到一个焦点的光线将经过另一个焦点。

- 圆锥曲线的离心率：圆锥曲线的离心率（eccentricity）是一个非负实数，它描述了圆锥曲线的形状。对于椭圆，离心率*e*满足0⩽*e*<1；对于双曲线，*e*>1；对于抛物线，*e*=1。离心率越小，椭圆越接近圆形；离心率越大，双曲线的两支越开。

#### 1.1.2. 向量表示与坐标变换

在 Python 中我们可以使用 NumPy 库来创建和操作向量，例如：

```python
import numpy as np
x = np.array([1, 2, 3, 5, 8])
# array([1, 2, 3, 5, 8])
```

这样我们便创建了一个向量。随后便可以进行各种操作。

解析几何法的本质就是利用函数与方程来表示不同的几何曲线。在中学阶段我们都学习过圆锥曲线的方程形式，但在实际问题中我们面临的曲线会更加复杂。尤其是在三维空间中的曲线与曲面，可能会用到多元函数去进行表示，也可能用极坐标或参数方程更加方便，但不管怎么说，解析几何方法的本质就是把各种几何问题都转化为代数问题求解。解方程比起复杂的分析，更依靠计算，而这恰恰是程序所擅长的。

在数学中，坐标变换通常涉及到一系列的矩阵运算，这些矩阵描述了一个坐标系相对于另一个坐标系的位置和方向。旋转变换就是其中的一个典型例子。当我们说一个坐标系相对于另一个坐标系进行了旋转，我们通常是指它绕着一个轴或者点旋转了一定的角度。二维空间的旋转可以简化为点绕原点旋转，而三维空间则涉及到更复杂的轴向旋转。

![](G:\笔记\picture\1-1.png)

在二维空间中，如果我们要将坐标系绕原点旋转一个角度，就可以通过旋转矩阵来实现。旋转矩阵是一个非常简单而又强大的工具，它可以将原始坐标系中的点通过线性变换映射到新坐标系中。对于逆时针旋转，二维旋转矩阵的形式是
$$
\left[\matrix{
  \cos \theta & -\sin\theta\\
  \sin \theta & \cos\theta 
}
\right]
$$
这里，*θ*是旋转角度，当应用这个旋转矩阵于一个点(*x*,*y*)，它会给出新的坐标(*x*′,*y*′)，这表示了原始点在新坐标系中的位置。

使用NumPy进行这样的变换非常简单。首先，我们创建一个表示点坐标的NumPy数组，然后创建表示旋转矩阵的二维数组。通过对这两个数组进行点积运算（也就是矩阵乘法），我们就可以得到新的坐标，在Python中可以这样实现：

```python
import numpy as np

# 设定旋转角度，这里我们以30度为例
theta = np.radians(30)  # 将30度转换为弧度

# 创建旋转矩阵
rotation_matrix = np.array([
    [np.cos(theta), -np.sin(theta)],
    [np.sin(theta), np.cos(theta)]
])

# 假设我们有一个点 (a, b)
point = np.array([a, b])

# 通过旋转矩阵变换这个点的坐标
rotated_point = rotation_matrix.dot(point)

print("原坐标为:", point)
print("旋转后的坐标为:", rotated_point)
# 原坐标为: [5 3]
# 旋转后的坐标为: [2.83012702 5.09807621]
```

此示例代码中，旋转角度是预设的，你可以根据实际情况调整。通过这种方式，我们能够将几何问题通过坐标变换转化为代数问题，使用编程方法来进行高效的计算。这不仅仅适用于理论数学问题，同样也适用于工程、物理学、计算机图形学以及机器人技术等多个领域中。

![](G:\笔记\picture\1-2.png)

在三维空间中，物体的旋转可以围绕三个主轴进行：x轴， y轴和z轴。这些轴旋转代表了不同方向的运动，并且可以通过旋转矩阵来数学描述。例如，一个点*P*(*x*,*y*,*z*)绕z轴旋转角度*α*可以表示为
$$
R_Z(\alpha) = 
\left[\matrix{
	\cos \alpha & -\sin\alpha & 0\\
	\sin\alpha & \cos\alpha&0\\
	0 & 0 & 1
}
\right]
$$
这个旋转保持z坐标不变，同时*X* *Y*平面上变换x和y坐标。相似地，点*P*绕y轴旋转角度*β*的旋转矩阵为
$$
R_y(\beta) = 
\left[\matrix{
	\cos \beta & 0 & \sin\beta\\
	0 & 1 & 0\\
	-\sin\beta &0& \cos\beta
}
\right]
$$
这个旋转保持yy坐标不变，同时在XZ*XZ*平面上变换xx和zz坐标。而点P*P*绕xx轴旋转角度γ*γ*的旋转矩阵为
$$
R_y(\beta) = 
\left[\matrix{
	1&0&0\\
	0&\cos\gamma&-\sin\gamma\\
	0&\sin\gamma&\cos\gamma
}
\right]
$$
这个旋转保持xx坐标不变，同时在*Y* *Z*平面上变换y和z坐标。若点*P*需同时围绕三个轴旋转，则最终旋转矩阵R*R*为这三个矩阵的乘积，即
$$
R=R_z(\alpha)R_y(\beta)R_x(\gamma)
$$
。需要注意的是，由于矩阵乘法的非交换性，旋转的顺序会影响最终结果。

在实际应用中，如机器人学、航空航天和计算机图形学，旋转顺序对于模拟和预测物体如何移动至关重要。例如，飞机的姿态控制就极依赖于绕不同轴的旋转顺序，以精确地模拟和控制飞机的行动。在三维建模和动画制作中，这些旋转变换同样是创建动态、逼真场景的基础。

在Python中，利用NumPy库，我们可以使用如下代码片段来实现三维旋转变换：

```python
import numpy as np

# 定义欧拉角（以弧度为单位）
alpha = np.radians(30)  # 绕 z 轴的 Yaw 角度
beta = np.radians(45)   # 绕 y 轴的 Pitch 角度
gamma = np.radians(60)  # 绕 x 轴的 Roll 角度

# 构建对应的旋转矩阵
R_z = np.array([[np.cos(alpha), -np.sin(alpha), 0],
                [np.sin(alpha), np.cos(alpha), 0],
                [0, 0, 1]])
R_y = np.array([[np.cos(beta), 0, np.sin(beta)],
                [0, 1, 0],
                [-np.sin(beta), 0, np.cos(beta)]])
R_x = np.array([[1, 0, 0],
                [0, np.cos(gamma), -np.sin(gamma)],
                [0, np.sin(gamma), np.cos(gamma)]])

# 总旋转矩阵，注意乘法的顺序
R = np.dot(R_x, np.dot(R_y, R_z))

print("组合旋转矩阵为:")
print(R)
# 组合旋转矩阵为:
# [[ 0.61237244 -0.35355339  0.70710678]
#  [ 0.78033009  0.12682648 -0.61237244]
#  [ 0.12682648  0.9267767   0.35355339]]
```

当你运行这段代码，它会打印出综合所有三次旋转的旋转矩阵R。

### 1.2. Numpy与线性代数

在本节中，我们将探讨Python中最强大的科学计算库之一：NumPy。在深入学习之前，我们需要弄清楚线性代数在实际应用中的重要性。线性代数不仅是理解数据结构、解决数学问题的基础，也是计算机图形学、机器学习等高级领域不可或缺的工具。NumPy库在这里扮演了至关重要的角色，因为它为我们提供了一个高效、便捷的平台来处理数值计算和线性代数运算。接下来的内容，将通过实际的例子展示如何使用NumPy来执行一些基础但强大的线性代数操作。

#### 1.2.1. Numpy向量与矩阵的操作

在科学计算的世界里，NumPy的数组对象是我们解决问题的得力助手。它能让我们轻松地执行向量化运算，这意味着可以一次性处理数据集而不需要使用循环。这种处理方式不仅代码更加简洁，而且运行速度也远快于传统的Python循环。在Numpy中，向量和矩阵都可以用二维数组表示，让我们来看看基本操作。

**创建向量和矩阵**

```python
import numpy as np
# 创建向量
vector = np.array([1, 2, 3])
# 创建矩阵
matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

```

**向量和矩阵的基本属性**

```python
# 向量的维度
print(vector.shape) # (3, )
# 矩阵的维度
print(matrix.shape) # (3, 3)
# 矩阵的行数和列数
print(matrix.shape[0])  # 行数, 3
print(matrix.shape[1])  # 列数, 3Copy to clipboardErrorCopied
```

**索引和切片**

```python
# 索引
print(vector[0])  # 输出第一个元素, 1
print(matrix[1, 1])  # 输出第二行第二列的元素, 5

# 切片
print(vector[0:2])  # 输出前两个元素, [1, 2]
print(matrix[0:2, 0:2])  # 输出左上角的2x2子矩阵, [[1, 2], [4, 5]]Copy to clipboardErrorCopied
```

**向量和矩阵的运算**

```python
# 向量加法
vector1 = np.array([1, 2, 3])
vector2 = np.array([4, 5, 6])
print(np.add(vector1, vector2))
# [5, 7, 9]

# 矩阵乘法
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
print(np.dot(matrix1, matrix2))  # 或使用 matrix1 @ matrix2
# [[19, 22],
#  [43, 50]]Copy to clipboardErrorCopied
```

#### 1.2.2. 利用Numpy进行线性代数基本运算

在NumPy中，我们可以利用数组的**广播机制**来进行各种线性代数运算。例如，你可以轻松地将一个标量与一个向量或矩阵相乘，而不需要编写任何循环。NumPy也提供了计算矩阵的转置、行列式、逆矩阵等常见操作的函数。

```python
import numpy as np

# 数量乘法示例
scalar = 5
scaled_vector = scalar * vector
print("Scaled vector:", scaled_vector)
# Scaled vector: [ 5 10 15]

# 矩阵的转置示例
transposed_matrix = matrix.T
print("Transposed matrix:\n", transposed_matrix)
# Transposed matrix:
# [[1, 4, 7]
#  [2, 5, 8]
#  [3, 6, 9]]

# 计算行列式示例
matrix_determinant = np.linalg.det(matrix)
print("Matrix determinant:", matrix_determinant)
# Matrix determinant: 0.0

# 求解线性方程组示例
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])
solution = np.linalg.solve(A, b)
print("Solution of the linear system:", solution)
# Solution of the linear system: [2. 3.]
Copy to clipboardErrorCopied
```

#### 1.2.3. numpy.linalg 的使用

最后，我们不能不提NumPy中的 `linalg` 子模块，它包含了一系列关于线性代数的函数。无论是求解方程组，还是计算特征值、特征向量，乃至执行奇异值分解，`linalg` 模块都能够提供帮助。通过这些工具，我们可以探索矩阵的深层属性，并应用于各种数学和工程问题。下面是一些 `numpy.linalg` 模块的使用示例：

**计算逆矩阵**

```python
import numpy as np
# If the matrix is singular, use the pseudo-inverse
pseudo_inverse_matrix = np.linalg.pinv(matrix)
print("Pseudo-inverse of the matrix:")
print(pseudo_inverse_matrix)
# Pseudo-inverse of the matrix:
# [[-6.38888889e-01 -1.66666667e-01  3.05555556e-01]
#  [-5.55555556e-02  4.20756436e-17  5.55555556e-02]
#  [ 5.27777778e-01  1.66666667e-01 -1.94444444e-01]]
Copy to clipboardErrorCopied
```

**特征值和特征向量**

```python
eigenvalues, eigenvectors = np.linalg.eig(matrix)
print(eigenvalues)
# [ 1.61168440e+01 -1.11684397e+00 -1.30367773e-15]

print(eigenvectors)
# [[-0.23197069 -0.78583024  0.40824829]
#  [-0.52532209 -0.08675134 -0.81649658]
#  [-0.8186735   0.61232756  0.40824829]]
Copy to clipboardErrorCopied
```

**奇异值分解**

```python
U, S, V = np.linalg.svd(matrix)
print(U)
# [[-0.21483724  0.88723069  0.40824829]
#  [-0.52058739  0.24964395 -0.81649658]
#  [-0.82633754 -0.38794278  0.40824829]]

print(S)
# [1.68481034e+01 1.06836951e+00 4.41842475e-16]

print(V)
# [[-0.47967118 -0.57236779 -0.66506441]
#  [-0.77669099 -0.07568647  0.62531805]
#  [-0.40824829  0.81649658 -0.40824829]]
Copy to clipboardErrorCopied
```

> 在np的计算中存在浮点数误差，特征向量形成矩阵转置乘以特征向量形成矩阵并不完全等于单位矩阵，故按步骤计算和直接调用函数存在一定误差。感谢学习者提问，这里回答一下。

**范数计算**

```python
norm = np.linalg.norm(vector)
print(norm)
# 3.7416573867739413
```

### 1.5. 使用Python解方程与方程组

在科学计算和工程应用中，经常会遇到需要求解方程或方程组的问题。Python提供了强大的数学库，如Numpy和Sympy，可以帮助我们轻松地解决这些问题。

#### 1.5.1. 利用Numpy求线性方程（组）的数值解

Numpy是Python中一个用于数值计算的库，它提供了很多用于矩阵运算的功能。我们可以使用Numpy中的linalg.solve函数来解线性方程组。例如，我们有以下方程组：
$$
10x - y - 2a = 72,\\
-x+10y-2z=83,\\
-x-y+5z=42.
$$
我们可以使用以下代码来求解这个方程组：

```python
import numpy as np
a = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]])
b = np.array([[72], [83], [42]])
c = np.linalg.solve(a, b)
print(c)
#[[11.]
# [12.]
# [13.]]

此外，我们还可以使用矩阵的逆来求解方程组，即：
x = np.linalg.inv(a).dot(b)
print(x)
# [[11.]
# [12.]
# [13.]]
```

#### 1.5.2. 利用Sympy求方程（组）的解析解

Sympy是python中一个用于符号计算的库，它可以提供方程的解析解，而不仅仅是数值解。什么是解析解和数值解呢？简单来说，解析解是指用数学符号（如x*x*、y*y*、π*π*等）表示的解，而数值解是指用具体的数字表示的解。

在Sympy中，我们首先需要创建符号变量，然后使用 `solve` 函数来求解方程或方程组。例如：

```python
from sympy import symbols, solve, nonlinsolve

x, y = symbols('x y')
print(solve(x * 2 - 2, x))  # 解方程2x - 2 = 0
# [1]

print(solve([x + y - 35, x * 2 + y * 4 - 94], x, y))  # 解方程组x + y = 35, 2x + 4y = 94
# {x:23, y:12}

print(solve(x**2 + x - 20, x))  # 解方程x^2 + x - 20 = 0
# [-5, 4]

a, b, c, d = symbols('a b c d', real=True)
print(nonlinsolve([a**2 + a + b, a - b], [a, b]))  # 解非线性方程组a^2 + a + b = 0, a - b = 0
# {(-2, -2), (0, 0)}
```

以下是一个具体案例：

![Pasted_image_20240417124525](G:\笔记\picture\Pasted_image_20240417124525.png)

图12 平面型Stewart平台示意图

图12给出的是平面型Stewart平台示意图，它模拟一个操作装置，其中包括一个三角形(*ABC*)平台，平台位于一个由3个支柱(*P*1, *P*2和*P*3)控制的固定平面中。图中的三角形(*ABC*)表示平面型Stewart平台，它的尺寸由3个长度*L*1，*L*2，*L*3确定。平台的位置由3个支柱的可变长度的3个参数*P*1，*P*2，*P*3所控制。需要解决的问题是，在给定一组参数*P*1，*P*2，*P*3的值后，计算出A*A*点的坐标(*x*,*y*)和角度θ*θ*的值(*θ*是*L*3与*x*轴的夹角)。请你完成：

1. 数学建模：参数*L*1,*L*2,*L*3,*x*1,*x*2,*y*2是固定常数，在给定一组参数*P*1,*P*2,*P*3的值后，判断能否得到Stewart平台的一个位置，即能否得到A*A*点坐标(*x*,*y*)和角度*θ*的值。如果能，则称它为Stewart平台的一个**位姿**。但位姿并不一定是唯一的，如何让你的模型能够计算出一组固定参数下的全部位姿。
2. 模型检验：假设有如下参数: *x*1=5, (*x*2,*y*2)=(0,6)，*L*1=*L*3=3, *L*2=3, *p*1=*p*2=5, *p*3=3，请根据你的模型，计算出Stewart平台的全部位姿，即计算出每个Stewart平台中的*A*点坐标(*x*,*y*)和角度*θ*的值。

**定义问题的几何关系**

*A*点的坐标：由于*A*点位于支柱*P*1的顶端，我们可以使用距离公式确定*A*点的坐标。这是一个圆的方程，表示所有与原点距离为*P*1的点集合。方程如下：
$$
x^2+y^2=P_1^2
$$
角度*β*的计算：角度*ΔABC*的内角，根据余弦定理，我们有：
$$
\cos\beta=\frac{L_2^2+L_3^2-L_1^2}{2L_2L_3}
$$
*B*点的坐标：*B*点相对于*A*点的位置可以用角度*θ*表示，根据*A*点的坐标和角度*θ*，我们可以写出*B*点的坐标
$$
B(x_B,y_B) = (x + L^3\cos\theta, y + L^3\sin\theta)
$$
*C*点的坐标：同样地，*C*点相对于*A*点的位置可以用角度*β*+*θ*来确定，于是*C*点的坐标为：
$$
C(x_C,y_C)=(x+L^2\cos(\beta+\theta), y+L^2\sin(\beta + \theta))
$$
**建立方程组**

*B*点与*P*2的距离关系：由于*B*点还位于支柱的顶端，所以我们有第二个方程：
$$
(x_B-x_1)^2+y_B^2=P_2^2
$$
*C*点与*P*3的距离关系：同理，*C*点位于支柱的顶端，所以我们有第三个方程：
$$
(x_C-x_2)^2+(y_C-y_2)^2=P_3^2
$$
**解方程组以确定A点坐标和角度θ**

- 方程求解：我们现在有三个方程和两个未知数 *x* 和 *y*。为了求解 *x* 和 *y*，我们可以用任何一个方程消去 后解一个二元一次方程组。
- 多解的情况：这组方程可能有多个解，对应于不同的物理位置和Stewart平台的不同位姿。
- 数值求解：在实践中，通常需要通过数值方法来解这类方程组，例如使用牛顿法或者数值优化算法。
- 模型检验：给定的参数 *x*1=5, (*x*2,*y*2)=(0,6)，*L*1=*L*3=3, *L*2=3, *p*1=*p*2=5, *p*3=3 可以代入上述方程组中进行求解。这将验证模型的正确性，并给出所有可能的Stewart平台位姿。

通过上述步骤，我们不仅可以找到*A*点的坐标和角度*θ* ，而且还可以确定Stewart平台的多个可能位姿，这些位姿对应于不同的解集。这是一个典型的运动学问题，其解决方案涉及几何、三角函数以及数值计算。

#### 1.5.3. 利用Scipy方程（组）的数值解

在进行数值求解时，`fsolve` 是 Scipy 库中用于解决非线性方程组的一个非常有用的函数。它通常用于查找方程组的根，其中方程组可以是非线性的，并且不保证有解析解。接下来我们将会对1.5.2小节例题进行求解。

首先，尝试使用 Sympy 库解方程组时，我们发现问题无法解决。这是因为所面临的方程组可能没有简洁的解析解，或者是解析解超出了Sympy库的计算范围。以下是尝试解方程的代码和得到的结果：

```python
from sympy import symbols, cos, sin, pi, nonlinsolve
import numpy as np
x, y, theta = symbols('x y theta', real=True)
L1, L2, L3 = 3, 3, 3
p1, p2, p3 = 5, 5, 3
x1, x2, y2 = 5, 0, 6
# 计算内角β
b = np.arccos((L2**2 + L3**2 - L1**2) / (2 * L2 * L3))
print(b)
# 尝试解方程组
solution = nonlinsolve([
    (x + L3 * cos(theta) - x1)**2 + (y + L3 * sin(theta))**2 - p1**2,
    x**2 + y**2 - p2**2,
    (x + L2 * cos(pi/3 + theta))**2 + (y + L2 * sin(pi/3 + theta) - y2)**2 - p3**2
], [x, y, theta])
print(solution)
# 1.0471975511965979
```

得到的输出表明，我们没有找到方程组的解析解。在这种情况下，我们转向数值解法，特别是Scipy库中的`fsolve`函数，来找到方程组的数值解。以下是使用`fsolve`的案例：

执行以上代码，我们得到了方程组的一组数值解。

上面的代码中，`equations` 函数定义了一个方程组，它接受一个变量列表（在这里是 `x`, `y`, 和 `theta`），然后返回一个方程组列表。然后，我们使用 `fsolve` 来求解这个方程组，并且提供了一个初始猜测值列表 `initial_guess`。`fsolve` 会尝试找到这些方程的根，这意味着它会寻找满足方程组为零的 `x`, `y`, 和 `theta` 的值。

在 Scipy 库中，除了 `fsolve`，还有其他几个函数可以用于解决类似的问题，比如：

- `brentq` 或 `bisection`：这些函数是用于求解单变量方程的根的，适用于在指定区间内具有一个根的情况。
- `root`：这个函数提供了一个更加通用的接口来求解多变量方程组的根，它允许选择不同的算法，比如 `hybr`, `lm`, `broyden1`, 等等。
- `newton`：用于求解单变量方程的根，当你有方程的导数信息时特别有用。

对于复杂的方程组，尤其是当没有解析解时，使用数值方法通常是解决问题的可行方式。**在使用数值方法时，很重要的一点是要有一个合理的初始猜测，因为这些方法很大程度上依赖于起始点，并且可能收敛到局部解，或者在某些情况下可能根本不收敛。**

### 本章小结

本章是数学建模的一个导引章节。在这一章节中，我们一起探索了几何模型在数学建模中的基础应用和实际操作。从向量表示法的初步了解到复杂立体几何模型的构建，再到运用Python编程语言中的 Numpy、Sympy、Scipy 等库求解方程和方程组，我们一步步深入了解了几何模型的精髓。

我们首先回顾了几何建模的基本思想，并探讨了向量表示和坐标变换的重要性。这不仅巩固了我们的几何基础知识，也为后续的学习打下了坚实的基础。接着，通过Numpy的强大功能，我们学习了线性代数中向量与矩阵的操作，以及如何运用Numpy.linalg库来进行基本的线性代数运算。

随后，我们针对平面几何模型和立体几何模型分别进行了深入的分析和建模。在每个问题中，我们不仅建立了数学模型，还通过模型的求解与讨论，实践了数学建模的全过程，这无疑增强了我们解决实际问题的能力。

在使用Python解方程与方程组的部分，我们学习了如何利用不同的Python库来解决具体的数学问题。这些内容不仅仅是理论上的，更多的是实践操作，让我们在解决实际问题时更加得心应手。

作为本章的结束，希望大家不仅理解了几何模型的构建方法，而且能够领会背后的数学原理，并将这些知识应用到现实生活中去。在接下来的章节中，我们将进一步学习更多高级的数学建模技巧和方法。请大家继续保持好奇心和探索精神，相信在数学建模的道路上会有更多的发现和成就。

祝愿各位读者在学习的旅途中收获知识，享受创造的乐趣，不断提升自己的问题解决能力。在这个以数据和模型驱动的时代，让我们共同成长为理解世界的数学建模者。

## 2. 微分方程与动力系统

这一章我们主要介绍微分方程与一些动力系统模型。数学上对微分方程的研究是一项热点问题，在工程当中微分方程与动力系统也有着广泛的应用。我们除了会从高等数学与计算数值方法的角度分析微分方程的求解方法与底层逻辑，还会介绍在数学模型当中被广泛应用的微分方程模型。本章主要涉及到的知识点有：

- 微分方程的解法
- 如何用python解微分方程
- 偏微分方程及其求解方法
- 微分方程的基本案例
- 差分方程的求解
- 数值计算方法
- 元胞自动机

注意：本章的重点是理解微分方程在实际工程中的应用。如果对数学基础有疑问，可以参考相关的高等数学和数值分析教材。

### 2.1. 微分方程的理论基础

微分方程是什么？如果你参加过高考，可能在高三备考中遇到过这样的问题：给定函数*f*(*x*)及其导数之间的等式，然后分析函数的性质，如单调性、零点等，但没有给出函数的解析式。这时你可能会想，如果能通过这个方程求出函数的通项形式该多好！微分方程的目的就是这样，它通过将函数*f*和它的若干阶导数联系起来形成一个方程（组），来求出函数的解析式或函数值随自变量变化的曲线。

#### 2.1.1. 函数、导数与微分

微分和导数其实是紧密相关的概念。我们通常将导数理解为函数在某一点处切线的斜率。而微分则描述的是当我们对自变量x施加一个非常小的增量d*x*时，函数值相应的变化量与d*x*之间的关系。当d*x*非常小的时候，函数的变化量就接近于在该点处切线的变化量d*y*。因此，我们可以用这种方式来理解微分：
$$
\frac{dy}{dx} = f^`(x)
$$
在图2.1.1中，我们展示了函数、导数和微分之间的关系。微分实际上描述的是点*M*处切线的斜率；导数则描述的是割线*MN*的斜率。但当d*x*足够小的时候，切线的斜率和割线的斜率就会非常接近，这就是微分的核心概念。而微分方程，就是描述函数与其导数之间关系的方程。

![Pasted_image_20240423220303](G:\笔记\picture\Pasted_image_20240423220303.png)

相对于求微分，我们还有求积分的概念。积分本质上是根据已知的导数反推出原函数，这就是不定积分。而定积分则是在反推出原函数后，还需要计算该函数在特定区间内的值的差异。通常情况下，我们可以通过查阅常见函数的导数表来进行微分和不定积分的计算。

> 注意：割线斜率等于切线斜率的前提是dx非常小，这是一种极限思想的体现。虽然它们之间存在一个无穷小量PN的差距，但当我们在考虑dx时，这种差异就可以忽略不计了。这就是微分和积分的基本思想。

#### 2.1.2. 一阶线性微分方程的解

一阶线性微分方程描述的是怎么一回事呢？它是指形如下方的方程：
$$
\frac{dy}{dX} + yP(x) = Q(X)
$$
这里的*y*是一个未知函数，而*P*和*Q*是已知的函数。我们的目标是找出*y*的解，即它的通解形式。为了解这个方程，我们通常会使用分离变量积分法和常数变易法这两种方法。首先，我们尝试解一个特殊情况的齐次方程，即当*Q*(*x*)=0时：
$$
\frac{dy}{dx}+yP(x)=0
$$
通过变量分离和变形，我们可以得到：
$$
\frac{1}{y}dy=P(x)dx
$$
接着，对两边进行不定积分，我们可以得到解的通式为
$$
y=C\exp \{-\int P(x)dx\}，
$$
其中*C*是一个常数。但在一般情况下，*Q*(*x*)不一定为0，所以我们需要将常数*C*替换为一个函数*C*(*x*)，然后对*y*求导并将其代入原方程中以求得*C*(*x*)的通解。这就是所谓的常数变易法。有兴趣的读者可以进一步推导出方程的通解为（其中*C*为常数）：
$$
y=\exp\{-\int P(x)dx\}[\int Q(x)\exp \{\int P(X)dx\}dx + C].
$$

> 注意：这里的定积分符号用于求原函数。这就是为什么我们在高中学习的积分符号应该按照这种方式书写的原因。齐次方程指的是方程右边等于0的情况，而非齐次方程则是方程右边不恒等于0的情况。解非齐次方程更具有一般性，但很多非齐次方程的解也是基于齐次方程的解进行拓展的。

#### 2.1.3. 二阶常系数线性微分方程的解

二阶常系数线性微分方程可以表示为：
$$
f^{``}(x) + pf^`(x)+qf(x) = C(x)
$$
这个方程关联了二阶导数、一阶导数和函数本身。解决这个方程的一般策略是先考虑对应的齐次方程，即让*C*(*x*)为0：
$$
f^{``}(x)+pf^`(x)+qf(x)=0
$$
解这种二阶常系数齐次线性微分方程时，我们通常使用特征根法。这个方法的关键是求解特征方程：
$$
r^2+pr+q=0
$$
这个齐次方程的解的形式取决于特征方程的根。根据特征方程的不同实根、相同实根、或共轭复根，齐次微分方程的解会有不同的形式：
$$
\begin{cases}
	y = C_1e^{\alpha_1x} + C2e^{\alpha_2x},\space\space\space\space r_1=\alpha_1,r_2=\alpha_2(1)\\
	y=(C_1x+C_2)e^{\alpha x},\space\space\space\space r_1=r_2=\alpha(2)\\
    y=e^{\alpha x}[C_1\sin(\beta x)+C_2\cos(\beta x)].\space\space\space\space r=\alpha \pm \beta i(3)
\end{cases}
$$

> 注意：这里可能有些读者不太明白为什么二次方程的根与齐次方程的解之间会有联系，这正是数学之美的体现之一。如果想检验这个方程的解是否正确，实际上并不难，可以使用 Vieta 定理将 *p* 和 *q* 代入，将两个方程统一起来，再通过换元法将其降为一阶微分方程进行验证。

对于一般的二阶非齐次线性微分方程，我们可以根据右侧*C*(*x*)的形式推导出一个特解。非齐次方程的通解等于齐次方程的通解加上非齐次方程的特解。求微分方程的特解有时需要观察法，但幸运的是，存在两种特殊形式：
$$
C(x)=P_m(x)e^{\lambda x},\\
C(x)=e^{\lambda x}[P_m\cos (\omega x)+Q_n(x)\sin(\omega x)]
$$
其中 *P* *m*(*x*)是一个m*m*次多项式，*Q* *n*(*x*)是一个*n*次多项式。这两种形式的特解分别为：
$$
f(x)=x_kP_m(x)e^{\lambda x},\\
f(x)=x^ke^\lambda x[P_i\cos(\omega x) + Q_i(x)\sin(\omega x)].\space\space\space\space i=\max\{m, n\}
$$
其中*k*的取值取决于特征方程根的个数：如果有两个不同的实根，则*k*=2；如果有两个相同的实根，则*k*=1；如果没有实根，则*k*=0。通过上述形式，我们可以解出二阶线性微分方程。

特征根法和“特解+通解”的策略不仅适用于二阶线性微分方程，也适用于一般的高阶线性微分方程。只要特征方程是多项式，它至少满足韦达定理。在后续的差分方程中，特征根法同样会发挥重要作用。

#### 2.1.4. 利用Python求函数的微分与积分

在Python中，我们可以使用Numpy和SciPy这两个库来进行函数的微分和积分计算。下面将通过具体示例来说明如何使用这些库来求解函数的微分和积分。 假设我们需要计算函数`f(x) = cos(2πx) * exp(-x) + 1.2`在区间`[0, 0.7]`上的定积分。我们可以使用SciPy库中的`quad`函数来完成这个任务：

```python
import numpy as np
from scipy.integrate import quad
# 定义函数
def f(x):
    return np.cos(2 * np.pi * x) * np.exp(-x) + 1.2
# 计算定积分
integral, error = quad(f, 0, 0.7)
print(f'定积分的结果是：{integral}')
# 定积分的结果是：0.7951866427656943 
```

除了使用SciPy库中的`quad`函数求解定积分外，我们还可以使用数值积分的方法来近似计算。一种常见的数值积分方法是梯形法则。下面我们将通过一个示例来说明如何使用梯形法则来近似计算函数的定积分。 假设我们需要计算函数`f(x) = cos(2πx) * exp(-x) + 1.2`在区间`[0, 0.7]`上的定积分。我们可以使用梯形法则来近似求解：

```python
h=x[1]-x[0]
xn=0.7
s=0
for i in range(1000):
    xn1=xn+h
    yn=np.cos(2*np.pi*xn)*np.exp(-xn)+1.2
    yn1=np.cos(2*np.pi*xn1)*np.exp(-xn1)+1.2
    s0=(yn+yn1)*h/2
    s+=s0
    xn=xn1
s
# 24.31183595181452
```

对于函数的微分，我们可以使用Numpy库中的`gradient`函数来近似求解。例如，我们想要求解函数`f(x) = x^2`在点`x = 1`处的导数：

```python
import numpy as np
# 定义x的取值范围和步长
x = np.linspace(0, 2, 100)
y = x**2
# 计算导数
dydx = np.gradient(y, x)
# 在x=1处的导数值
derivative_at_1 = dydx[np.argmin(abs(x - 1))]
print(f'在x=1处的导数值是：{derivative_at_1}')
# 在x=1处的导数值是：1.9797979797979792
```

以上示例展示了如何在Python中求解函数的积分和微分。在实际应用中，可以根据具体问题调整函数表达式、积分区间和微分点等参数。

### 2.2. 使用Scipy和Sympy解微分方程

前面我们见过了求微分方程解析解的一些方法，我们知道，微分方程的解本质上是通过给定函数与微分之间的关系求解出函数的表达式。但是事实上，大多数微分方程是没有解析解的，也就是无法求解出函数的具体解析式。这是不是意味着这样的微分方程不可解呢？也不尽然。在上一章中我们已经见过了，以前我们难以求解的超越方程也是可能给出数值解的，那么微分方程是否也会存在数值解呢？

#### 2.2.1 使用sympy求解微分方程解析解

我们此前介绍的一阶、二阶常系数线性微分方程通解的形式就是一种解析解，但在科学与工程实际中我们遇到的微分方程形式会比这些基本形式更为复杂，条件也更多。事实上多数情况下，大多数微分方程其实是求不出解析解的，只能在不同取值条件下求一个数值解。那么如何编写算法去求数值解才能使精度尽可能提高呢？数值解会随着初始条件而变化，怎么变化呢？函数值又与自变量之间怎么变化呢？

在回答这些问题之前，请让我们先了解一番：如何使用python求解微分方程的解析解呢？但凡涉及到符号运算，通常都是使用sympy库实现。Sympy是一个数学符号运算库。能解决积分、微分方程等各种数学运算方法，用起来也是很简单，效果可以和Matlab媲美。其中内置的Sympy.dsolve方法是解微分方程解析解的一种良好方式，而对于有初始值的微分方程问题，我们通常在求出其通解形式后通过解方程组的方法得到参数。这个方法通过声明符号变量的方式求得最优解。

例如，我们看下面这个例子： **例2.1** 使用sympy解下面这个微分方程：
$$
y^{''} + 2y^{'}+y=x^2.
$$
若使用sympy，我们首先要声明两个符号变量，其中变量`y`是变量`x`的函数。代码如下：

```python
from sympy import *
y = symbols('y', cls=Function)
x = symbols('x')
eq = Eq(y(x).diff(x,2)+2*y(x).diff(x,1)+y(x), x*x)
## y''+4y'+29y=0
print(dsolve(eq, y(x)))
```

这段代码通过sympy中的`symbols`类创建两个实例化的符号变量`x`和`y`，在`y`中我们通过`cls`参数声明`y`是一个`scipy.Function`对象（也就是说，`y`是一个函数）。表达微分方程解析解的方法是通过创建一个`Eq`对象，这个对象分别存储方程左右两边。其中，`y(x).diff(x,2)`表明`y`是`x`的函数，然后需要取函数对`x`的2阶导数。最后，若想求解函数`y`的解析式，只需要调用`dsolve(eq,y(x))`函数即可。代码返回结果：

```python
Eq(y(x), x**2 - 4*x + (C1 + C2*x)*exp(-x) + 6)
```

可以看到，代码能够给出完整的解析式。之所以还保留了参数`C1`和`C2`是因为在求解过程中没有给微分方程指定初值。

我们再来看一个例子，这个例子是使用sympy解一个常微分方程组：

**例2.2** 使用sympy解下面这个常微分方程组：
$$
\begin{cases}\frac{dx_1}{dt}=2x_1-3x_2+3x_3,\space\space\space\space x_1(0)=1(6)\\ \frac{dx_2}{dt}=4x_1-5x_2+3x_3,\space\space\space\space x2(0)=2(7)\\ \frac{dx_3}{dt}=4x_1-4x_2+2x_3,\space\space\space\space x3(0)=3(8) \end{cases}
$$
这个方程组里面的x1,x2,x3*x*1,*x*2,*x*3都是关于t*t*的函数，所以需要声明四个符号变量。不同的是，在这里每个函数都指定了初始值，并且三个函数的导数高度相关，该怎么描述这种相关呢？我们来看下面的例子：

```python
t=symbols('t')
x1,x2,x3=symbols('x1,x2,x3',cls=Function)
eq=[x1(t).diff(t)-2*x1(t)+3*x2(t)-3*x3(t),
    x2(t).diff(t)-4*x1(t)+5*x2(t)-3*x3(t),
    x3(t).diff(t)-4*x1(t)+4*x2(t)-2*x3(t)]
con={x1(0):1, x2(0):2, x3(0):3}
s=dsolve(eq,ics=con)
print(s)
```

sympy当中内置的`symbols`工具是可以通过字符串批量创建变量的，这为我们带来了很大的方便。如果需要求解的是一个方程组，则使用列表将每一个方程表达出来即可。这里我们采取了不创建对象的方式，而是直接将方程组移项使每个方程右侧都为`0`。通过字典的方式保存函数的初始值，并利用`ics`参数传入`dsolve`从而得到方程的解。

```python
[Eq(x1(t), 2*exp(2*t) - exp(-t)), Eq(x2(t), 2*exp(2*t) - exp(-t) + exp(-2*t)), Eq(x3(t), 2*exp(2*t) + exp(-2*t))]
```

结果返回的是一个`Eq`对象构成的列表，每个对象代表了一个函数的解析式。对于这个例子，大家可以发现：它是一个线性的微分方程组，而针对线性方程我们还可以使用矩阵的形式去表示。所以，这个问题还有第二种写法：

```python
x=Matrix([x1(t),x2(t),x3(t)])
A=Matrix([[2,-3,3],[4,-5,3],[4,-4,2]])
eq=x.diff(t)-A*x
s=dsolve(eq,ics={x1(0):1, x2(0):2, x3(0):3})
print(s)
```

通过sympy中内置的符号矩阵`Matrix`对象构造函数向量和系数矩阵，通过对方程组矩阵化也可以得出一样的结果。返回值同上。使用sympy中的符号函数绘图得到结果如下：

```python
from sympy.plotting import plot
from sympy import *
t=Symbol('t')
plot(2*exp(2*t) - exp(-t), line_color='red')
plot(2*exp(2*t) - exp(-t) + exp(-2*t), line_color='blue')
plot(2*exp(2*t) + exp(-2*t), line_color='green')
```

![img](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423223752.png)

图2.1.2 sympy求解图

sympy通过plotting下面的plot功能可以进行一些符号函数的绘图，但每一次调用都会创建一个独立的图窗，难以在同一张图上绘制多个函数的曲线。若要绘制多个函数则需要使用matplotlib来完成。

#### 2.2.2 使用scipy求解微分方程数值解

微分方程的数值解是什么样子的呢？虽然大多数微分方程没有解析解，但解析式也并不是唯一可以表示函数的形式。函数的表示还可以用列表法和作图法来表示，而微分方程的数值解也正是像列表一样针对自变量数组中的每一个取值给出相对精确的因变量值。

Python求解微分方程数值解可以使用scipy库中的`integrate`包。在这当中有两个重要的函数：`odeint`和`solve_ivp`。但本质上，从底层来讲求解微分方程数值解的核心原理都是Euler 法和Runge-Kutta 法。关于这两个方法，我们会在后面进行进一步探讨。

我们先来了解一下`odeint`的用法吧。`odeint()`函数需要至少三个变量，第一个是微分方程函数，第二个是微分方程初值，第三个是微分的自变量。为了具体了解它的用法，我们通过一个例子来分析：

**例2.3** 使用scipy解下面这个微分方程的数值解：
$$
y^{'}=\frac{1}{1 + x^2}-2y^2,\space\space\space\space y(0)=0.
$$
首先需要通过`def`语句或者`lambda`表达式定义微分方程的表达式，然后定义微分方程的初值。代码如下：

```python
import matplotlib.pyplot as plt
dy=lambda y,x: 1/(1+x**2)-2*y**2 # y'=1/(1+x^2)-2y^2
'''
def dy(y,x):
    return 1/(1+x**2)-2*y**2
'''
x=np.arange(0,10.5,0.1) #从0开始，每次增加0.1，到10.5为止（取不到10.5）
sol=odeint(dy,0,x) # odeint输入：微分方程dy，y的首项（y(0)等于多少），自变量列表
print("x={}\n对应的数值解y={}".format(x,sol.T))
plt.plot(x,sol)
plt.show()
```

这里`odeint`函数传入的三个参数分别是函数表达式，函数的初值与自变量。自变量是一个数组，通过`numpy.arange`生成一个范围在`[0, 10.5)`的等差数列，公差为`0.1`。返回的结果`sol`是针对数组`x`中每个值的对应函数值，可以通过`matplotlib.pyplot`绘图得到函数的结果。函数的图像如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423224135.png)

图2.2.1 odeint函数求解图

我们再来看一个例子，这个例子是一个不可积函数的积分问题：

**例2.4** 使用scipy解下面这个微分方程的数值解：
$$
y^{'}=\sin t^2,\space\space\space\space y(0) = 1
$$
仿照例2.3中的代码，这个问题可以改写为：

```python
def dy_dt(y,t):
    return np.sin(t**2)
y0=[1]
t = np.arange(-10,10,0.01)
y=odeint(dy_dt,y0,t)
plt.plot(t, y)
plt.show()
```

得到的结果必然是一个奇函数，图像为：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423224303.png)

图2.2.2 scipy函数求解图

刚刚两个例子都是讲述了一阶微分方程如何求解，那么二阶及以上的高阶微分方程如何求解呢？事实上，Python求解微分方程数值解的时候是无法直接求解高阶微分方程的，必须通过换元降次的方法实现低阶化，把一个高阶微分方程替换成若干个一阶微分方程组成的微分方程组才能求解。具体的，我们可以看下面这个例子：

**例2.5** 使用scipy解下面这个高阶微分方程的数值解：
$$
y^{''}-20(1-y^2)y^{'}+y=0, \space\space\space\space y(0)=0,y^{'}(0)=2
$$
这很显然是个二阶微分方程，并且不是常系数所以不能直接给出解析解。为了给这个方程做降次，令*u*=*y*′，那么*y*′′=*u*′，式子就可以代换为：
$$
\begin{cases} u=y^{'},(9)\\ u^{'}-20(1-y^2)u+y=0,(10)\\ y(0)=0,(11)\\ u(0)=2.(12) \end{cases}
$$


对于微分方程组，我们传入`[y,u]`两个函数的原函数值，返回的函数值为`[y’,u’]`。所以，只需要对每个微分表达式给出解析形式就可以了。代码如下：

```python
# odeint是通过把二阶微分转化为一个方程组的形式求解高阶方程的
# y''=20(1-y^2)y'-y
def fvdp(y,t):
    '''
    要把y看出一个向量，y = [dy0,dy1,dy2,...]分别表示y的n阶导，那么
    y[0]就是需要求解的函数，y[1]表示一阶导，y[2]表示二阶导，以此类推
    '''
    dy1 = y[1]      # y[1]=dy/dt，一阶导                     y[0]表示原函数
    dy2 = 20*(1-y[0]**2) * y[1] - y[0]                    # y[1]表示一阶微分
    # y[0]是最初始，也就是需要求解的函数
    # 注意返回的顺序是[一阶导， 二阶导]，这就形成了一阶微分方程组
    return [dy1, dy2] 
    
# 求解的是一个二阶微分方程，所以输入的时候同时输入原函数y和微分y'
# y[0]表示原函数， y[1]表示一阶微分
# dy1表示一阶微分， dy2表示的是二阶微分
# 可以发现，dy1和y[1]表示的是同一个东西
# 把y''分离变量分离出来： dy2=20*(1-y[0]**2)*y[1]-y[0]
def solve_second_order_ode():
    '''
    求解二阶ODE
    '''
    x = np.arange(0,0.25,0.01)#给x规定范围
    y0 = [0.0, 2.0] # 初值条件
    # 初值[3.0, -5.0]表示y(0)=3,y'(0)=-5
    # 返回y，其中y[:,0]是y[0]的值，就是最终解，y[:,1]是y'(x)的值
    y = odeint(fvdp, y0, x)
    
    y1, = plt.plot(x,y[:,0],label='y')
    y1_1, = plt.plot(x,y[:,1],label='y‘')             
    plt.legend(handles=[y1,y1_1])   #创建图例
    
    plt.show()
solve_second_order_ode()
```

定义函数`fvdp`，传入`y`的原函数值和一阶导数值（列表传入），返回`y`的一阶导数值和二阶导数值。初值条件`y(0)=0`和`y'(0)=2`传入`odeint`函数中，自变量是取值`[0, 0.25)`的一个等距数组。解得的`y`其实包含两列，第一列是函数值，第二列是导数值。结果的图像如下。

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423224853.png)

图2.2.3 fvdp函数求解图

图2.1.5展示的是原函数$y(x)$与一阶导数$y'(x)$的图像。从图像中可以看到，原函数$y(x)$呈现出一种振荡衰减的趋势，随着$x$的增加，$y(x)$的振幅逐渐减小，最终趋于稳定。这是因为二阶微分方程中的非线性项起到了阻尼作用，当y的绝对值接近$1$时，该项的值变小，从而减弱了$y$的增长速率，导致振荡的衰减。

同时，一阶导数*y*′(*x*)的图像显示出与原函数相似的振荡衰减模式，但相比之下，其变化更加剧烈。这是因为直接受到非线性阻尼项的影响，而y*y*则是间接受到影响。

总的来说，这个微分方程组描述了一个非线性阻尼振荡系统，其解的行为随着初始条件和时间的变化而发生变化。在这个例子中，初始条件*y*(0)=0和*y*′(0)=2导致了一个振荡衰减的解，这种解在物理学和工程学中很常见，用于描述许多实际系统的动态行为。

我们再来看一个更高阶函数的求解的案例。

**例2.6** 使用scipy解下面这个高阶微分方程的数值解：
$$
y^{'''}+y^{''}-y^{'}+y=\cos t,\space\space\space\space y(0)=0,y^{'}=\pi ,y^{''}(0)=0
$$
这个案例当然可以和上面一样如法炮制，输入`[y, y', y'']`返回`[y', y'', y''']`。这里再次介绍一个案例是想引出Python求微分方程数值解的另一个函数`solve_ivp`的用法。

首先，仍然是通过换元法对函数进行定义：

```python
def f(y,t):
    dy1 = y[1]
    dy2 = y[2]
    dy3 = -y[0]+dy1-dy2-np.cos(t)
    return [dy1,dy2,dy3]
```

`Solve_ivp`函数的用法与`odeint`非常类似，只不过比`odeint`多了两个参数。一个是`t_span`参数，表示自变量的取值范围；另一个是`method`参数，可以选择多种不同的数值求解算法。常见的内置方法包括`RK45`, `RK23`, `DOP853`, `Radau`, `BDF`等多种方法，通常使用`RK45`多一些。它的使用方法与`odeint`对比起来很类似，对这个问题进行代码实现如下：

```python
import numpy as np
from scipy.integrate import odeint, solve_ivp
import matplotlib.pyplot as plt

pi = np.pi

# 用于 odeint 的函数
def f_odeint(y, t):
    dy1 = y[1]  # First derivative
    dy2 = y[2]  # Second derivative
    dy3 = -y[0] + y[1] - y[2] - np.cos(t)  # Third derivative
    return [dy1, dy2, dy3]

# 用于 solve_ivp 的函数
def f_solve_ivp(t, y):
    dy1 = y[1]  # First derivative
    dy2 = y[2]  # Second derivative
    dy3 = -y[0] + y[1] - y[2] - np.cos(t)  # Third derivative
    return [dy1, dy2, dy3]

def solve_high_order_ode():
    '''
    求解高阶ODE
    '''
    t = np.linspace(0, 6, 1000)
    tspan = (0.0, 6.0)
    y0 = [0.0, pi, 0.0]  # 初始条件: y(0)=0, y'(0)=π, y''(0)=0

    # 使用 odeint 求解
    y_odeint = odeint(f_odeint, y0, t)

    # 使用 solve_ivp 求解
    sol = solve_ivp(f_solve_ivp, t_span=tspan, y0=y0, t_eval=t)  # Ensure the correct function is used here

    plt.figure(figsize=(10, 8))

    plt.subplot(211)
    plt.plot(t, y_odeint[:, 0], label='y(0) Initial Function (odeint)')
    plt.plot(t, y_odeint[:, 1], label='y(1) First Derivative (odeint)')
    plt.plot(t, y_odeint[:, 2], label='y(2) Second Derivative (odeint)')
    plt.legend()
    plt.grid(True)

    plt.subplot(212)
    plt.plot(sol.t, sol.y[0], 'r--', label='y(0) Initial Function (solve_ivp)')
    plt.plot(sol.t, sol.y[1], 'g--', label='y(1) First Derivative (solve_ivp)')
    plt.plot(sol.t, sol.y[2], 'b-', label='y(2) Second Derivative (solve_ivp)')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()

solve_high_order_ode()
```

> solve_ivp 和 odeint 两个函数都可以解偏微分方程，但是solve_ivp可以不考虑参数顺序，odeint必须要考虑参数顺序（经验之谈）。

这里通过`matplotlib.pyplot`中提供的绘图接口绘制了两个数值解的图像。由于没有设置`method`参数，这里默认`solve_ivp`使用`RK45`（4-5阶 Runge-Kutta 法）方法进行求解。所解得的结果如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423225734.png)

图2.2.4 Runge-Kutta 法求解图

图中上半部分是使用`odeint`求解得到的结果，下半部分是由`solve_ivp`得到的结果，二者大差不差。一般来说对于普通的微分方程`odeint`与`solve_ivp`得到的结果差异不会太大，但有些情况下函数的微分容易发散，就会导致求解结果出现比较大的差异。`odeint`内置的原理也是4-5阶 Runge-Kutta 法，版本比较早所以求解也相对较为稳定。但`solve_ivp`则是后来新增的方法，有可能出现不太稳定的现象，内置方法较多所以也更加灵活。

Python求解微分方程组的模式有两种：一是采用基于基本原理自己写相关函数，这样操作比较繁琐，但是对于整个的求解过程会比较清晰明了；第二就是利用python下面的ode求解器，熟悉相关的输入输出，就可以完成数值求解。基于这个demo，在不同方向领域可以套用不同的微分方程组模型，进行仿真求解。但无论是常微分方程组还是偏微分方程组，使用的都是同一套思路，就是用差分代替微分。

**例2.7** 使用scipy解下面这个微分方程组的数值解：
$$
\begin{cases} x^{'}(t)=-x^3-y,(13) \\ y^{'}(t)=-y^3+x.(14) \end{cases}
$$
这个例子和例2.2很像，但不同的是这是也一个非线性方程组。那么，输入就需要以数组的形式传入`[x, y]`两个函数的函数值，返回它们的导数值。这里使用`solve_ivp`对这个方程组进行求解如下：

```python
def fun(t, w):
    x = w[0]
    y = w[1]
    return [-x**3-y,-y**3+x]
# 初始条件
y0 = [1,0.5]
yy = solve_ivp(fun, (0,100), y0, method='RK45',t_eval = np.arange(0,100,0.2) )
t = yy.t
data = yy.y
plt.plot(t, data[0, :])
plt.plot(t, data[1, :])
plt.xlabel("时间s")
plt.show()
```

绘制图像如图所示：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423230056.png)

图2.2.5 solve_ivp函数求解图

可以看到二者处于相互干扰的震荡状态，振幅随着时间的推移逐渐收敛并趋于稳定。 如果在微分方程组里面还出现了高阶微分，我们又应该怎么做呢？来看下面这个例子：

**例2.8** 使用 scipy 解下面这个微分方程组的数值解：
$$
\begin{cases} x^{''}(t)+y^{'}(t)+3x(t)=\cos (2t),\space\space (15)\\ y^{''}(t)-4x{'}(t)+3y(t)=\sin (2t), \space\space (16) \\ x^{'}(0)=\frac{1}{5}, y^{'}(0)=\frac{6}{5},x(0)=y(0)=0.\space\space (17) \end{cases}
$$
这个例子就比较有趣了，在方程组里面涉及到了两个函数的导数怎么求解呢？本质上还是要使用换元法。完全可以令*u*=*x*’, *v*=*y*’，然后带入到方程组中把一个二元二阶微分方程组变为四元一阶微分方程组。代码实现如下所示：

```python
def fun(t, w):
    x = w[0]
    y = w[1]
    dx = w[2]
    dy = w[3]
    # 求导以后[x,y,dx,dy]变为[dx,dy,d2x,d2y]
    # d2x为w[2]，d2y为w[5]
    return [dx,dy,-dy-3*x+np.cos(2*t),4*dx-3*y+np.sin(2*t)]
# 初始条件
y0 = [0,0,1/5,1/6]
yy = solve_ivp(fun, (0,100), y0, method='RK45',t_eval = np.arange(0,100,0.2) )
t = yy.t
data = yy.y
plt.figure(figsize=(12,6))
plt.subplot(1,2,1)
plt.plot(t, data[0, :])
plt.plot(t, data[1, :])
plt.legend(['x','y'])
plt.xlabel("时间s")
plt.subplot(1,2,2)
plt.plot(t, data[2, :])
plt.plot(t, data[3, :])
plt.legend(["x' ","y' "])
plt.xlabel("时间s")
plt.show()
```

得到的图像如图所示：

![600](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423230519.png)

图2.2.6 四元一阶方程求解图

可以看到，图像呈现出一定的周期规律但并不是简谐运动。这样的方程解往往在物理学中有着实际意义，例如，这样的方程可以描述物体同时出现平动和摆动的过程中，位移-速度-加速度与角度-角速度-角加速度之间存在的关系。这样的例子曾出现在2022年全国大学生数学建模竞赛A题中，我们后面可以看到。 最后一个例子是对蝴蝶效应的求解。

例2.9 使用scipy求解洛伦兹系统的数值解，参数与初始值自设：
$$
\begin{cases} \frac{dx}{dt}=p(y-x),(18)\\ \frac{dx}{dt}=x(r-z),(19)\\ \frac{dz}{dt}=xy-bz,(20) \end{cases}
$$
有前面的例子作为经验，我们知道x y z都是函数其余的都是参数。利用solve_ivp很容易求解这个系统的代码：

```python
import numpy as np
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
def dmove(Point, t, sets):
    p, r, b = sets
    x, y, z = Point
    return np.array([p*(y-x), x*(r-z), x*y-b*z])
t = np.arange(0, 30, 0.001)
P1 = odeint(dmove, (0., 1., 0.), t, args=([10., 28., 3.],))
P2 = odeint(dmove, (0., 1.01, 0.), t, args=([10., 28., 3.],)) 
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(P1[:,0], P1[:,1], P1[:,2])
ax.plot(P2[:,0], P2[:,1], P2[:,2])
plt.show()
```

`Mpl_toolkits.mplot3d`提供了进行三维曲线、曲面绘制的函数，这里使用里面提供的三维坐标系绘制洛伦兹系统中点的运动轨迹。我们这里基于不同的初值绘制了两个点的轨迹`P1`和`P2`，并展示在图中：

![500](https://datawhalechina.github.io/intro-mathmodel/CH2/attachments/Pasted%20image%2020240423231009.png)

图2.2.7 洛伦兹系统中点的运动轨迹图

可以看到，曲线的形状呈现双螺旋状，有些像蝴蝶的翅膀。所以洛伦兹系统又被叫做“蝴蝶效应”。蝴蝶效应本质上就是指，即使给这个系统的初始值一点微小的变化，曲线的形状也会出现很大不同。仅仅是把$y$改变了$0.01$，曲线的密集程度与蝴蝶翅膀的大小也是有所不同的。这是个混沌系统里面的典型案例。

